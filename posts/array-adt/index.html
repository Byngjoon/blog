<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Data Structures] [01] Array Abstract Data Type (ADT) | Hyungtae</title>
<meta name="keywords" content="Data Structures">
<meta name="description" content="Understanding the Array Abstract Data Type in Data Structures">
<meta name="author" content="">
<link rel="canonical" href="https://Byngjoon.github.io/blog/posts/array-adt/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://Byngjoon.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://Byngjoon.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Byngjoon.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://Byngjoon.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://Byngjoon.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://Byngjoon.github.io/blog/posts/array-adt/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
<script>
  window.onload = function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  };
</script>

<meta property="og:url" content="https://Byngjoon.github.io/blog/posts/array-adt/">
  <meta property="og:site_name" content="Hyungtae">
  <meta property="og:title" content="[Data Structures] [01] Array Abstract Data Type (ADT)">
  <meta property="og:description" content="Understanding the Array Abstract Data Type in Data Structures">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-17T07:27:31+09:00">
    <meta property="article:modified_time" content="2025-05-17T07:27:31+09:00">
    <meta property="article:tag" content="Data Structures">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Data Structures] [01] Array Abstract Data Type (ADT)">
<meta name="twitter:description" content="Understanding the Array Abstract Data Type in Data Structures">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Byngjoon.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Data Structures] [01] Array Abstract Data Type (ADT)",
      "item": "https://Byngjoon.github.io/blog/posts/array-adt/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Data Structures] [01] Array Abstract Data Type (ADT)",
  "name": "[Data Structures] [01] Array Abstract Data Type (ADT)",
  "description": "Understanding the Array Abstract Data Type in Data Structures",
  "keywords": [
    "Data Structures"
  ],
  "articleBody": "Chapter 01. Array ADT and Implementation Outline:\nThis chapter introduces the Array Abstract Data Type (ADT) as a foundational structure in data organization.\nIt explores both the abstract model (ADT) and its concrete implementations in C, including static and dynamic arrays.\nThrough this chapter, you will gain a clear understanding of array operations, memory layout, pointer behaviors, and their practical use cases and limitations.\nThis chapter also highlights the motivation for more flexible structures like linked lists and addresses typical interview questions related to arrays.\nContents 1.1. Array Abstract Data Type (ADT) 1.2. What Is an Array in C? 1.3. Implementing Static Arrays in C 1.4. Memory Model and Pointer Behavior in Arrays 1.5. Multidimensional Arrays 1.6. Dynamic (Resizable) Arrays in C 1.7. Limitations of Arrays and Why Linked Lists Are Needed 1.8. Arrays vs Pointers in C (optional) Section 1.1. Array Abstract Data Type (ADT) 1.1.1. What Is the Array ADT? The Array Abstract Data Type (ADT) is a logical model that represents a fixed-size, index-based, and homogeneous (동종의) collection of elements. Each element is identified by an integer index and stored in a specific position. An array ADT can also be formally described as a collection of ordered pairs ⟨index, value⟩, where each valid index maps uniquely to a corresponding value: ⟨0, A[0]⟩, ⟨1, A[1]⟩, …, ⟨n−1, A[n−1]⟩ Indices(the plural form of index) are typically zero-based, and valid indices range from 0 to size - 1.\nThis abstraction allows for constant-time access to any element using its index and forms the basis of many efficient algorithms and data structures. For a detailed explanation of what an Abstract Data Type (ADT) is, refer to Chapter 00, Section 0.3.\nEssential Properties of the Array ADT:\nProperty Description Fixed Size The number of elements is determined at creation and does not change Indexed Access Each element is accessible via a unique integer index (0-based indexing) Homogeneous All elements belong to the same data type 1.1.2. Array ADT Specification Objects:\nA fixed-size, indexed sequence of elements of the same type.\nOperations:\ncreate(size)\n::= Creates an array that can hold size number of elements.\nget(A, i)\n::= Returns the element at index i from array A.\nset(A, i, v)\n::= Stores value v at index i in array A.\nlength(A)\n::= Returns the number of elements in array A.\ntraverse(A)\n::= Visits each element of array A in order.\nsearch(A, x)\n::= Returns the index of value x in array A, if present.\ninsert(A, i, x)\n::= Inserts x at index i in array A; elements may shift.\ndelete(A, i)\n::= Deletes the element at index i; elements may shift to fill the gap.\nSummary of Array ADT Operations\nOperation Signature Time Complexity Remarks (촌평) Create create(size) O(1) Initializes a fixed-size array Get get(A, i) O(1) Returns value at index i; constant-time random access Set set(A, i, v) O(1) Updates value at index i Length length(A) O(1) Returns current number of elements Traverse traverse(A) O(n) Iterates over all elements Search search(A, x) O(n) Linear search; may return first matching index Insert insert(A, i, x) O(n) Requires shifting elements to make space Delete delete(A, i) O(n) Requires shifting elements to fill the gap Note:\nOperations such as insert and delete are inefficient in fixed-size arrays because they often require shifting multiple elements, which leads to a higher time complexity. This limitation is one of the primary reasons for introducing linked lists, which support more efficient insertions and deletions.\n1.1.3. Example Usage Scenario A leaderboard holding the top 100 player scores → indexed access is efficient A monthly calendar with 31 days → fixed-size, one-to-one mapping with indices A timetable grid (e.g., 7 days × 24 hours) → 2D array (to be discussed later) Summary\nThe Array ADT is the simplest and most efficient structure for fixed-size, index-based, homogeneous data.\nHowever, due to its rigid(고정된, 굳은) size and costly insertion/deletion, it is best suited for static datasets.\nSection 1.2. What Is an Array in C? 1.2.1. Definition In the C programming language, an array is a fixed-size collection of elements of the same type stored in contiguous memory locations. Each element is accessed using an index, with indexing starting at zero.\nArrays in C are not dynamic by default. Once declared, the size of an array cannot be changed.\nCharacteristics\nFeature Description Fixed size Must be declared with a known size Static allocation Memory allocated at compile time Same-type elements All elements must be of one data type Index-based access Direct access via zero-based indexing 1.2.2. Basic Syntax Declaration Example:\nint scores[5]; // Declares an array of 5 integers char name[20]; // Declares an array of 20 characters float prices[10]; // Declares an array of 10 floats The above declarations allocate memory for a fixed number of elements. The size must be a constant at compile time.\nInitialization Example:\nint A[5] = {1, 2, 3, 4, 5}; // full initialization int B[5] = {1, 2}; // partial, rest are zero int C[] = {10, 20, 30}; // size inferred from initializer Arrays can be initialized at the time of declaration. If fewer initializers are provided, the remaining elements are zero-initialized. (i.e. Uninitialized elements are filled with 0 only if((충족)한다면) at least one initializer is provided.) If the size is omitted, it is inferred from the number of initializers.\nAccess and Modification Example:\nscores[1] = 85; // update value printf(\"%d\", scores[1]); // access value C allows indexed access to each element of array using square brackets []. Indexing starts at 0 (i.e., the first element is arr[0], the last is arr[size - 1]). Accessing an out-of-bounds index leads to undefined behavior, due to the lack of built-in bounds checking in C.\n1.2.3. Memory Layout and Indexing Arrays are stored in contiguous memory, meaning each element is placed next to the previous one. This allows for efficient computation of any element’s address using the base address and offset.\nThe array name (scores, name, etc.) acts as a pointer to the first element. A contiguous block of memory allows for efficient random(임의) access to array elements using index arithmetic. (\\text{Address of } arr[i] = \\text{base_address} + (i \\times \\text{element_size})) (\\text{Address of } arr[i] = \\text{base_address} + (i \\times \\text{sizeof(data_type)})) This property makes array element access O(1) in time complexity. Example:\nint A[4] = {10, 20, 30, 40}; // Memory layout: A[0] → 10 A[1] → 20 A[2] → 30 A[3] → 40 1.2.4. Abstract View vs Concrete View (Array ADT vs Array in C) | Feature | Array ADT (Abstract) | Static Array in C (Implementation) | |—————————|—————————————————-|——————————- —————–| | Definition Level | Logical model | Language-level memory construct | | Size | Fixed at creation (create(size)) | Fixed at declaration (compile-time constant) | | Element Type | Homogeneous (same data type) | Must be same type (enforced by compiler) | | Indexing | Must support indexed access (e.g., get(i)) | Zero-based indexing with arr[i] | | Memory Layout | Abstract – does not specify how memory is arranged | Contiguous memory layout | | Bounds Checking | Not defined (depends on implementation) | No built-in bounds checking | | Mutability | Allows set(i, value) operation | Allows mutation via arr[i] = value | | Language Independence | Yes | No (specific to C) |\nArrays in C provide efficient random access due to their contiguous memory layout,\nbut they have limitations such as a fixed size and the lack of built-in bounds checking.\nSection 1.3. Implementing Static Arrays in C 1.3.1. What Is a Static Array? A static array in C is an array whose size is known and fixed at compile time. Its memory is allocated either on the stack (for local variables) or in the data segment (for global/static variables).\nStatic here(여기에서, 이 문장에서) refers to fixed-size allocation, not necessarily the use of the static keyword.\n1.3.2. Declaring and Using Static Arrays Declaration:\nint A[5]; // Declares an array of 5 integers Initialization:\nfor (int i = 0; i \u003c 5; i++) { A[i] = i * 10; } Traversal:\nfor (int i = 0; i \u003c 5; i++) { printf(\"A[%d] = %d\\n\", i, A[i]); } Output:\nA[0] = 0 A[1] = 10 A[2] = 20 A[3] = 30 A[4] = 40 1.3.3. Common Operations on Static Arrays Operation Code Example Time Complexity Access x = A[3]; O(1) Update A[2] = 99; O(1) Traverse for loop with indexing O(n) Search Linear search via loop O(n) Insert/Shift Manual shifting needed O(n) Delete Simulate or shift O(n) 1.3.4. Example: Linear Search in Static Array int search(int A[], int n, int key) { for (int i = 0; i \u003c n; i++) { if (A[i] == key) return i; } return -1; // not found } 1.3.5. Limitations of Static Arrays Limitation Explanation Fixed size Cannot grow/shrink at runtime No insert/delete Requires manual element shifting Memory waste or overflow Over-allocation wastes memory; under-allocation causes limits No boundary check Accessing invalid index causes undefined behavior Summary\nStatic arrays in C are efficient for fixed-size data with known limits.\nThey provide fast access but lack dynamic features like resizing or safe insert/delete.\nSection 1.4. Memory Model and Pointer Behavior in Arrays 1.4.1. Memory Model of Arrays In C, arrays are stored in contiguous memory locations, which means that all elements are laid out one after another in memory without any gaps.\nExample: Given:\nint A[4] = {10, 20, 30, 40}; The memory layout might look like:\nAddress Content Index 0x1000 10 A[0] 0x1004 20 A[1] 0x1008 30 A[2] 0x100C 40 A[3] If int is 4 bytes, then the address of A[i] is computed as: base_address + (i × sizeof(int))\nThis direct computation allows constant-time access: O(1).\n1.4.2. Array Name as a Pointer In most contexts, the name of an array behaves like a pointer to its first element.\nExample:\nint A[3] = {1, 2, 3}; int *p = A; Here:\nA is automatically converted to \u0026A[0] p now points to the first element of array A p[1] is equivalent to *(p + 1) and to A[1] However, A is not a pointer variable; it’s a symbolic name for the array and cannot be reassigned like a pointer.\n1.4.3. Pointer Arithmetic on Arrays You can perform pointer arithmetic using array names or pointer variables:\nExamples:\n*(A + 2) // same as A[2] *(p + 2) // same as p[2] *(A + i) // equivalent to A[i] You can also iterate over an array using a pointer:\nint *ptr = A; for (int i = 0; i \u003c 3; i++) { printf(\"%d\\n\", *(ptr + i)); } 1.4.4. Differences Between Arrays and Pointers Aspect Array Pointer Modifiability Cannot be reassigned Can be reassigned sizeof operator Size of entire array Size of pointer (e.g., 8 bytes) Memory allocation Contiguous block Points to any address Storage duration Stack or data segment Stack, heap, or data segment Example:\nint A[5]; int *p = A; sizeof(A) → 20 (if int is 4 bytes) sizeof(p) → 8 (on 64-bit machine) Summary\nArrays are stored in contiguous memory and support fast indexed access. In most contexts, an array name acts like a pointer to the first element. However, arrays and pointers are not the same, and knowing the differences is essential to avoid memory errors. More about pointer and array\nSection 1.5. Multidimensional Arrays 1.5.1. What Is a Multidimensional Array? A multidimensional array is an array of arrays. In C, the most common type is the two-dimensional array (2D array), which can be visualized as a table or matrix with rows and columns.\nDeclaration syntax:\ntype array_name[rows][columns]; Example:\nint matrix[3][4]; // 3 rows, 4 columns // This creates a contiguous memory block to store 12 integers (3 × 4 = 12). 1.5.2. Memory Layout Even though a 2D array is written as a table, it is stored linearly in row-major order in memory.\nExample:\nint A[2][3] = { {1, 2, 3}, {4, 5, 6} }; Memory layout:\nAddress Value Index 0x1000 1 A[0][0] 0x1004 2 A[0][1] 0x1008 3 A[0][2] 0x100C 4 A[1][0] 0x1010 5 A[1][1] 0x1014 6 A[1][2] If int is 4 bytes, each element takes 4 bytes, and rows are stored one after another.\n1.5.3. Accessing Elements To access a specific element: A[i][j] → element in the ith row and jth column\nExample:\nA[1][2] = 99; // sets the last element to 99 printf(\"%d\", A[0][1]); // prints 2, int A[2][3] = { {1, 2, 3}, {4, 5, 99} }; 1.5.4. Traversing a 2D Array Nested loops are commonly used:\nfor (int i = 0; i \u003c rows; i++) { for (int j = 0; j \u003c cols; j++) { printf(\"%d \", A[i][j]); } printf(\"\\n\"); } 1.5.5. Common Pitfalls Mistake Explanation Omitting column size int A[][3] is valid, but int A[][] is invalid Assuming A[i][j] = A[j][i] Only symmetric for square matrices (not always true) Using wrong dimensions Declaring A[3][2] and accessing A[2][3] → undefined behavior In function parameters, the number of columns must be specified, because row size alone isn’t enough to compute addresses.\nSummary\nMultidimensional arrays store data in a row-major linear memory block. Access is done via multiple indices (e.g., A[i][j]). Column size is essential for correct memory calculations. Useful for matrices, grids, tables, and more. Section 1.6. Dynamic (Resizable) Arrays in C 1.6.1. Motivation C arrays are fixed-size by default. Once an array is declared with a specific size, it cannot be resized.\nHowever, many real-world applications require:\nVariable-sized inputs (e.g., user input, file contents) Dynamic data growth (e.g., appending items) This is where dynamic memory allocation becomes necessary.\n1.6.2. Allocating Dynamic Arrays C provides the library functions for memory allocation:\nmalloc(size) – allocate uninitialized memory calloc(n, size) – allocate and zero-initialize memory realloc(ptr, new_size) – resize previously allocated memory free(ptr) – release allocated memory Example: Allocating an int array for n elements\nint *arr; int n = 5; arr = (int *)malloc(n * sizeof(int)); if (arr == NULL) { printf(\"Memory allocation failed\\n\"); exit(1); } 1.6.3. Using and Resizing To access elements:\narr[0] = 10; arr[1] = 20; To resize (e.g., double the size):\nn = 10; arr = (int *)realloc(arr, n * sizeof(int)); if (arr == NULL) { printf(\"Reallocation failed\\n\"); exit(1); } To release memory when done:\nfree(arr); 1.6.4. Benefits and Risks Benefit Risk Can grow or shrink at runtime Manual memory management required Efficient use of memory Forgetting free() causes memory leaks Flexible for input size Dangling pointers if misused 1.6.5. Comparison with Static Arrays Feature Static Array Dynamic Array Size Fixed at compile time Determined at runtime Memory Stack or data segment Heap (via malloc, realloc) Flexibility Inflexible Resizable Bounds checking Not provided Still not provided Lifetime Automatic (if local) Manual malloc/free needed Summary\nC does not support built-in dynamic arrays like higher-level languages. You must use heap allocation functions like malloc() and realloc(). Always call free() to prevent memory leaks. Dynamic arrays are essential for variable-size data. Section 1.7. Limitations of Arrays and Why Linked Lists Are Needed 1.7.1. Limitations of Static and Dynamic Arrays Although arrays are efficient for indexed access, they have several limitations that make them less suitable for certain use cases:\nLimitation Description Fixed Size (Static) Static arrays cannot grow or shrink; their size is fixed at compile time. Manual Resizing Dynamic arrays require manual resizing using realloc(), which is costly. Costly Insertion Inserting an element in the middle requires shifting all subsequent items. Costly Deletion Similarly, deletion also requires shifting elements to fill the gap. Fragmentation Risk realloc() may move the array in memory, breaking previous pointers. 1.7.2. Use Case Example: Inserting at the Beginning Suppose we want to insert an element at the front of an array:\nint A[5] = {10, 20, 30, 40, 50}; // Insert 5 at A[0]; shift all elements for (int i = 4; i \u003e= 0; i--) { A[i + 1] = A[i]; } A[0] = 5; This process is O(n) due to the shifting. If we frequently insert or delete at arbitrary positions, arrays are inefficient.\n1.7.3. Why Linked Lists Help Linked lists solve many of the above issues by using nodes and pointers rather than contiguous memory.\nFeature Array Linked List Size Flexibility Fixed (or manually resized) Grows or shrinks dynamically Insertion/Deletion Costly (shift required) Efficient at head or tail Memory Layout Contiguous Non-contiguous (each node separate) Random Access O(1) O(n) (must traverse) Memory Overhead Low Higher (pointer + data per node) 1.7.4. When to Choose Linked Lists Linked lists are preferred when:\nThe number of elements is unknown or changes frequently. Frequent insertions/deletions are expected at arbitrary positions. Memory fragmentation is not a concern. Note: Arrays are still preferable when fast indexing and low memory overhead are important.\n1.7.5. Summary Arrays are simple and fast for indexed data access but become inefficient for frequent structural changes. Linked lists offer better flexibility at the cost of pointer overhead and slower access. Understanding their trade-offs is crucial before choosing one over the other. Section 1.8. Arrays vs Pointers in C 1.8.1. Conceptual Difference Feature Array Pointer Definition Collection of fixed-size, contiguous elements Variable storing the address of another variable Memory Allocation Automatically allocates a block of memory Must be explicitly assigned or allocated Reassignability Cannot reassign the array variable itself Pointer can be reassigned to another location Syntax int A[10]; int *p; and p = A; or p = malloc() 1.8.2. Array Name as a Pointer (When and How) In most expressions, the name of an array is converted to a pointer to its first element:\nint A[3] = {1, 2, 3}; int *p = A; // p points to A[0] printf(\"%d\", *(A + 1)); // prints 2 printf(\"%d\", p[2]); // prints 3 Both A[i] and *(A + i) are valid and equivalent. However: A = p; is illegal (you can’t assign to an array name) p = A; is legal (you can assign an array address to a pointer)\n1.8.3. sizeof Operator Difference int A[5]; int *p = A; printf(\"%zu\\n\", sizeof(A)); // Output: 20 (if int = 4 bytes) printf(\"%zu\\n\", sizeof(p)); // Output: 8 (on 64-bit systems) sizeof(A) = total memory size allocated for the array sizeof(p) = size of a pointer (not the array contents)\n1.8.4. Pointer Arithmetic and Access Both arrays and pointers support arithmetic operations like:\n*(p + i), A[i], p[i] However, only pointers can be incremented:\np++; // valid A++; // invalid (compile error) 1.8.5. Function Parameter Behavior When passing an array to a function, it decays to a pointer.\nvoid foo(int A[]) { // A is actually of type int* } void foo(int *A) { // Equivalent declaration } Therefore, you lose the size information unless it’s passed separately.\n1.8.6. Summary Aspect Array Pointer Syntax int A[10]; int *p = A; Memory Allocated at declaration Can be dynamic (via malloc) Reassignment Not allowed (A = ...) Allowed (p = ...) sizeof Operator Total memory of all elements Size of the pointer itself Arithmetic Limited (A++ illegal) Full pointer arithmetic allowed Function Parameter Form Decays to pointer Naturally a pointer Conclusion: Arrays and pointers in C share similar behaviors in terms of element access, but they are fundamentally different entities. Understanding their differences is crucial for safe memory manipulation and efficient programming in C.\nReferences\nKernighan \u0026 Ritchie, The C Programming Language, 2nd Edition ISO/IEC 9899:1999 CS50: Pointers and Memory Layout GeeksforGeeks: Static Arrays in C ",
  "wordCount" : "3203",
  "inLanguage": "en",
  "datePublished": "2025-05-17T07:27:31+09:00",
  "dateModified": "2025-05-17T07:27:31+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Byngjoon.github.io/blog/posts/array-adt/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hyungtae",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Byngjoon.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Byngjoon.github.io/blog/" accesskey="h" title="Hyungtae (Alt + H)">Hyungtae</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Byngjoon.github.io/blog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://Byngjoon.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [Data Structures] [01] Array Abstract Data Type (ADT)
    </h1>
    <div class="post-description">
      Understanding the Array Abstract Data Type in Data Structures
    </div>
    <div class="post-meta"><span title='2025-05-17 07:27:31 +0900 KST'>May 17, 2025</span>&nbsp;·&nbsp;16 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#chapter-01-array-adt-and-implementation" aria-label="Chapter 01. Array ADT and Implementation">Chapter 01. Array ADT and Implementation</a><ul>
                        
                <li>
                    <a href="#contents" aria-label="Contents">Contents</a></li>
                <li>
                    <a href="#section-11-array-abstract-data-type-adt" aria-label="Section 1.1. Array Abstract Data Type (ADT)">Section 1.1. Array Abstract Data Type (ADT)</a><ul>
                        
                <li>
                    <a href="#111-what-is-the-array-adt" aria-label="1.1.1. What Is the Array ADT?">1.1.1. What Is the Array ADT?</a></li>
                <li>
                    <a href="#112-array-adt-specification" aria-label="1.1.2. Array ADT Specification">1.1.2. Array ADT Specification</a></li>
                <li>
                    <a href="#113-example-usage-scenario" aria-label="1.1.3. Example Usage Scenario">1.1.3. Example Usage Scenario</a></li></ul>
                </li>
                <li>
                    <a href="#section-12-what-is-an-array-in-c" aria-label="Section 1.2. What Is an Array in C?">Section 1.2. What Is an Array in C?</a><ul>
                        
                <li>
                    <a href="#121-definition" aria-label="1.2.1. Definition">1.2.1. Definition</a></li>
                <li>
                    <a href="#122-basic-syntax" aria-label="1.2.2. Basic Syntax">1.2.2. Basic Syntax</a></li>
                <li>
                    <a href="#123-memory-layout-and-indexing" aria-label="1.2.3. Memory Layout and Indexing">1.2.3. Memory Layout and Indexing</a></li>
                <li>
                    <a href="#124-abstract-view-vs-concrete-view-array-adt-vs-array-in-c" aria-label="1.2.4. Abstract View vs Concrete View (Array ADT vs Array in C)">1.2.4. Abstract View vs Concrete View (Array ADT vs Array in C)</a></li></ul>
                </li>
                <li>
                    <a href="#section-13-implementing-static-arrays-in-c" aria-label="Section 1.3. Implementing Static Arrays in C">Section 1.3. Implementing Static Arrays in C</a><ul>
                        
                <li>
                    <a href="#131-what-is-a-static-array" aria-label="1.3.1. What Is a Static Array?">1.3.1. What Is a Static Array?</a></li>
                <li>
                    <a href="#132-declaring-and-using-static-arrays" aria-label="1.3.2. Declaring and Using Static Arrays">1.3.2. Declaring and Using Static Arrays</a></li>
                <li>
                    <a href="#133-common-operations-on-static-arrays" aria-label="1.3.3. Common Operations on Static Arrays">1.3.3. Common Operations on Static Arrays</a></li>
                <li>
                    <a href="#134-example-linear-search-in-static-array" aria-label="1.3.4. Example: Linear Search in Static Array">1.3.4. Example: Linear Search in Static Array</a></li>
                <li>
                    <a href="#135-limitations-of-static-arrays" aria-label="1.3.5. Limitations of Static Arrays">1.3.5. Limitations of Static Arrays</a></li></ul>
                </li>
                <li>
                    <a href="#section-14-memory-model-and-pointer-behavior-in-arrays" aria-label="Section 1.4. Memory Model and Pointer Behavior in Arrays">Section 1.4. Memory Model and Pointer Behavior in Arrays</a><ul>
                        
                <li>
                    <a href="#141-memory-model-of-arrays" aria-label="1.4.1. Memory Model of Arrays">1.4.1. Memory Model of Arrays</a></li>
                <li>
                    <a href="#142-array-name-as-a-pointer" aria-label="1.4.2. Array Name as a Pointer">1.4.2. Array Name as a Pointer</a></li>
                <li>
                    <a href="#143-pointer-arithmetic-on-arrays" aria-label="1.4.3. Pointer Arithmetic on Arrays">1.4.3. Pointer Arithmetic on Arrays</a></li>
                <li>
                    <a href="#144-differences-between-arrays-and-pointers" aria-label="1.4.4. Differences Between Arrays and Pointers">1.4.4. Differences Between Arrays and Pointers</a></li></ul>
                </li>
                <li>
                    <a href="#section-15-multidimensional-arrays" aria-label="Section 1.5. Multidimensional Arrays">Section 1.5. Multidimensional Arrays</a><ul>
                        
                <li>
                    <a href="#151-what-is-a-multidimensional-array" aria-label="1.5.1. What Is a Multidimensional Array?">1.5.1. What Is a Multidimensional Array?</a></li>
                <li>
                    <a href="#152-memory-layout" aria-label="1.5.2. Memory Layout">1.5.2. Memory Layout</a></li>
                <li>
                    <a href="#153-accessing-elements" aria-label="1.5.3. Accessing Elements">1.5.3. Accessing Elements</a></li>
                <li>
                    <a href="#154-traversing-a-2d-array" aria-label="1.5.4. Traversing a 2D Array">1.5.4. Traversing a 2D Array</a></li>
                <li>
                    <a href="#155-common-pitfalls" aria-label="1.5.5. Common Pitfalls">1.5.5. Common Pitfalls</a></li></ul>
                </li>
                <li>
                    <a href="#section-16-dynamic-resizable-arrays-in-c" aria-label="Section 1.6. Dynamic (Resizable) Arrays in C">Section 1.6. Dynamic (Resizable) Arrays in C</a><ul>
                        
                <li>
                    <a href="#161-motivation" aria-label="1.6.1. Motivation">1.6.1. Motivation</a></li>
                <li>
                    <a href="#162-allocating-dynamic-arrays" aria-label="1.6.2. Allocating Dynamic Arrays">1.6.2. Allocating Dynamic Arrays</a></li>
                <li>
                    <a href="#163-using-and-resizing" aria-label="1.6.3. Using and Resizing">1.6.3. Using and Resizing</a></li>
                <li>
                    <a href="#164-benefits-and-risks" aria-label="1.6.4. Benefits and Risks">1.6.4. Benefits and Risks</a></li>
                <li>
                    <a href="#165-comparison-with-static-arrays" aria-label="1.6.5. Comparison with Static Arrays">1.6.5. Comparison with Static Arrays</a></li></ul>
                </li>
                <li>
                    <a href="#section-17-limitations-of-arrays-and-why-linked-lists-are-needed" aria-label="Section 1.7. Limitations of Arrays and Why Linked Lists Are Needed">Section 1.7. Limitations of Arrays and Why Linked Lists Are Needed</a><ul>
                        
                <li>
                    <a href="#171-limitations-of-static-and-dynamic-arrays" aria-label="1.7.1. Limitations of Static and Dynamic Arrays">1.7.1. Limitations of Static and Dynamic Arrays</a></li>
                <li>
                    <a href="#172-use-case-example-inserting-at-the-beginning" aria-label="1.7.2. Use Case Example: Inserting at the Beginning">1.7.2. Use Case Example: Inserting at the Beginning</a></li>
                <li>
                    <a href="#173-why-linked-lists-help" aria-label="1.7.3. Why Linked Lists Help">1.7.3. Why Linked Lists Help</a></li>
                <li>
                    <a href="#174-when-to-choose-linked-lists" aria-label="1.7.4. When to Choose Linked Lists">1.7.4. When to Choose Linked Lists</a></li>
                <li>
                    <a href="#175-summary" aria-label="1.7.5. Summary">1.7.5. Summary</a></li></ul>
                </li>
                <li>
                    <a href="#section-18-arrays-vs-pointers-in-c" aria-label="Section 1.8. Arrays vs Pointers in C">Section 1.8. Arrays vs Pointers in C</a><ul>
                        
                <li>
                    <a href="#181-conceptual-difference" aria-label="1.8.1. Conceptual Difference">1.8.1. Conceptual Difference</a></li>
                <li>
                    <a href="#182-array-name-as-a-pointer-when-and-how" aria-label="1.8.2. Array Name as a Pointer (When and How)">1.8.2. Array Name as a Pointer (When and How)</a></li>
                <li>
                    <a href="#183-sizeof-operator-difference" aria-label="1.8.3. sizeof Operator Difference">1.8.3. sizeof Operator Difference</a></li>
                <li>
                    <a href="#184-pointer-arithmetic-and-access" aria-label="1.8.4. Pointer Arithmetic and Access">1.8.4. Pointer Arithmetic and Access</a></li>
                <li>
                    <a href="#185-function-parameter-behavior" aria-label="1.8.5. Function Parameter Behavior">1.8.5. Function Parameter Behavior</a></li>
                <li>
                    <a href="#186-summary" aria-label="1.8.6. Summary">1.8.6. Summary</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="chapter-01-array-adt-and-implementation">Chapter 01. Array ADT and Implementation<a hidden class="anchor" aria-hidden="true" href="#chapter-01-array-adt-and-implementation">#</a></h1>
<blockquote>
<p><strong>Outline:</strong><br>
This chapter introduces the <strong>Array Abstract Data Type (ADT)</strong> as a foundational structure in data organization.<br>
It explores both the abstract model (ADT) and its concrete implementations in C, including static and dynamic arrays.<br>
Through this chapter, you will gain a clear understanding of array operations, memory layout, pointer behaviors, and their practical use cases and limitations.<br>
This chapter also highlights the motivation for more flexible structures like linked lists and addresses typical interview questions related to arrays.</p></blockquote>
<hr>
<h2 id="contents">Contents<a hidden class="anchor" aria-hidden="true" href="#contents">#</a></h2>
<ul>
<li><a href="#section-11-array-abstract-data-type-adt">1.1. Array Abstract Data Type (ADT)</a></li>
<li><a href="#section-12-what-is-an-array-in-c">1.2. What Is an Array in C?</a></li>
<li><a href="#section-13-implementing-static-arrays-in-c">1.3. Implementing Static Arrays in C</a></li>
<li><a href="#section-14-memory-model-and-pointer-behavior-in-arrays">1.4. Memory Model and Pointer Behavior in Arrays</a></li>
<li><a href="#section-15-multidimensional-arrays">1.5. Multidimensional Arrays</a></li>
<li><a href="#section-16-dynamic-resizable-arrays-in-c">1.6. Dynamic (Resizable) Arrays in C</a></li>
<li><a href="#section-17-limitations-of-arrays-and-why-linked-lists-are-needed">1.7. Limitations of Arrays and Why Linked Lists Are Needed</a></li>
<li><a href="#section-18-arrays-vs-pointers-in-c">1.8. Arrays vs Pointers in C (optional)</a></li>
</ul>
<hr>
<h2 id="section-11-array-abstract-data-type-adt">Section 1.1. Array Abstract Data Type (ADT)<a hidden class="anchor" aria-hidden="true" href="#section-11-array-abstract-data-type-adt">#</a></h2>
<h3 id="111-what-is-the-array-adt">1.1.1. What Is the Array ADT?<a hidden class="anchor" aria-hidden="true" href="#111-what-is-the-array-adt">#</a></h3>
<ul>
<li>The <strong>Array Abstract Data Type (ADT)</strong> is a logical model that represents a <strong>fixed-size</strong>, <strong>index-based</strong>, and <strong>homogeneous</strong> (동종의) collection of elements. Each element is identified by an integer index and stored in a specific position.</li>
</ul>
<blockquote>
<p>An array ADT can also be formally described as a collection of ordered pairs <strong>⟨index, value⟩</strong>, where each valid index maps uniquely to a corresponding value:
⟨0, A[0]⟩, ⟨1, A[1]⟩, …, ⟨n−1, A[n−1]⟩
Indices(the plural form of index) are typically zero-based, and valid indices range from <code>0</code> to <code>size - 1</code>.</p></blockquote>
<ul>
<li>This abstraction allows for <strong>constant-time access</strong> to any element using its index and forms the basis of many efficient algorithms and data structures.</li>
</ul>
<blockquote>
<p>For a detailed explanation of what an Abstract Data Type (ADT) is, refer to <strong>Chapter 00, Section 0.3</strong>.</p></blockquote>
<hr>
<p><strong>Essential Properties of the Array ADT:</strong></p>
<table>
  <thead>
      <tr>
          <th>Property</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Fixed Size</strong></td>
          <td>The number of elements is determined at creation and does not change</td>
      </tr>
      <tr>
          <td><strong>Indexed Access</strong></td>
          <td>Each element is accessible via a unique integer index (0-based indexing)</td>
      </tr>
      <tr>
          <td><strong>Homogeneous</strong></td>
          <td>All elements belong to the same data type</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="112-array-adt-specification">1.1.2. Array ADT Specification<a hidden class="anchor" aria-hidden="true" href="#112-array-adt-specification">#</a></h3>
<ul>
<li>
<p><strong>Objects</strong>:<br>
A <strong>fixed-size</strong>, <strong>indexed</strong> sequence of elements of the <strong>same type</strong>.</p>
</li>
<li>
<p><strong>Operations</strong>:</p>
<ul>
<li>
<p><code>create(size)</code><br>
::= Creates an array that can hold <code>size</code> number of elements.</p>
</li>
<li>
<p><code>get(A, i)</code><br>
::= Returns the element at index <code>i</code> from array <code>A</code>.</p>
</li>
<li>
<p><code>set(A, i, v)</code><br>
::= Stores value <code>v</code> at index <code>i</code> in array <code>A</code>.</p>
</li>
<li>
<p><code>length(A)</code><br>
::= Returns the number of elements in array <code>A</code>.</p>
</li>
<li>
<p><code>traverse(A)</code><br>
::= Visits each element of array <code>A</code> in order.</p>
</li>
<li>
<p><code>search(A, x)</code><br>
::= Returns the index of value <code>x</code> in array <code>A</code>, if present.</p>
</li>
<li>
<p><code>insert(A, i, x)</code><br>
::= Inserts <code>x</code> at index <code>i</code> in array <code>A</code>; elements may shift.</p>
</li>
<li>
<p><code>delete(A, i)</code><br>
::= Deletes the element at index <code>i</code>; elements may shift to fill the gap.</p>
</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Summary of Array ADT Operations</strong></p>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Signature</th>
          <th>Time Complexity</th>
          <th>Remarks (촌평)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Create</td>
          <td><code>create(size)</code></td>
          <td>O(1)</td>
          <td>Initializes a fixed-size array</td>
      </tr>
      <tr>
          <td>Get</td>
          <td><code>get(A, i)</code></td>
          <td>O(1)</td>
          <td>Returns value at index <code>i</code>; constant-time random access</td>
      </tr>
      <tr>
          <td>Set</td>
          <td><code>set(A, i, v)</code></td>
          <td>O(1)</td>
          <td>Updates value at index <code>i</code></td>
      </tr>
      <tr>
          <td>Length</td>
          <td><code>length(A)</code></td>
          <td>O(1)</td>
          <td>Returns current number of elements</td>
      </tr>
      <tr>
          <td>Traverse</td>
          <td><code>traverse(A)</code></td>
          <td>O(n)</td>
          <td>Iterates over all elements</td>
      </tr>
      <tr>
          <td>Search</td>
          <td><code>search(A, x)</code></td>
          <td>O(n)</td>
          <td>Linear search; may return first matching index</td>
      </tr>
      <tr>
          <td>Insert</td>
          <td><code>insert(A, i, x)</code></td>
          <td>O(n)</td>
          <td>Requires shifting elements to make space</td>
      </tr>
      <tr>
          <td>Delete</td>
          <td><code>delete(A, i)</code></td>
          <td>O(n)</td>
          <td>Requires shifting elements to fill the gap</td>
      </tr>
  </tbody>
</table>
<hr>
<blockquote>
<p>Note:<br>
Operations such as <code>insert</code> and <code>delete</code> are inefficient in fixed-size arrays because they often require shifting multiple elements, which leads to a higher time complexity.
This limitation is one of the primary reasons for introducing linked lists, which support more efficient insertions and deletions.</p></blockquote>
<hr>
<h3 id="113-example-usage-scenario">1.1.3. Example Usage Scenario<a hidden class="anchor" aria-hidden="true" href="#113-example-usage-scenario">#</a></h3>
<ul>
<li>A leaderboard holding the top 100 player scores → indexed access is efficient</li>
<li>A monthly calendar with 31 days → fixed-size, one-to-one mapping with indices</li>
<li>A timetable grid (e.g., 7 days × 24 hours) → 2D array (to be discussed later)</li>
</ul>
<hr>
<blockquote>
<p><strong>Summary</strong><br>
The Array ADT is the simplest and most efficient structure for <strong>fixed-size, index-based, homogeneous data</strong>.<br>
However, due to its rigid(고정된, 굳은) size and costly insertion/deletion, it is best suited for <strong>static datasets</strong>.</p></blockquote>
<hr>
<h2 id="section-12-what-is-an-array-in-c">Section 1.2. What Is an Array in C?<a hidden class="anchor" aria-hidden="true" href="#section-12-what-is-an-array-in-c">#</a></h2>
<h3 id="121-definition">1.2.1. Definition<a hidden class="anchor" aria-hidden="true" href="#121-definition">#</a></h3>
<p>In the C programming language, an <strong>array</strong> is a fixed-size collection of elements of the same type stored in <strong>contiguous memory locations</strong>. Each element is accessed using an index, with indexing starting at zero.</p>
<blockquote>
<p>Arrays in C are <strong>not dynamic by default</strong>. Once declared, the size of an array cannot be changed.</p></blockquote>
<p><strong>Characteristics</strong></p>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Fixed size</td>
          <td>Must be declared with a known size</td>
      </tr>
      <tr>
          <td>Static allocation</td>
          <td>Memory allocated at compile time</td>
      </tr>
      <tr>
          <td>Same-type elements</td>
          <td>All elements must be of one data type</td>
      </tr>
      <tr>
          <td>Index-based access</td>
          <td>Direct access via zero-based indexing</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="122-basic-syntax">1.2.2. Basic Syntax<a hidden class="anchor" aria-hidden="true" href="#122-basic-syntax">#</a></h3>
<p><strong>Declaration Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> scores[<span style="color:#ae81ff">5</span>];       <span style="color:#75715e">// Declares an array of 5 integers
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">20</span>];       <span style="color:#75715e">// Declares an array of 20 characters
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> prices[<span style="color:#ae81ff">10</span>];    <span style="color:#75715e">// Declares an array of 10 floats
</span></span></span></code></pre></div><blockquote>
<p>The above declarations allocate memory for a fixed number of elements.
The size must be a <strong>constant</strong> at compile time.</p></blockquote>
<hr>
<p><strong>Initialization Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>};        <span style="color:#75715e">// full initialization
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> B[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>};                 <span style="color:#75715e">// partial, rest are zero
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> C[]  <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>};           <span style="color:#75715e">// size inferred from initializer
</span></span></span></code></pre></div><blockquote>
<p>Arrays can be initialized at the time of declaration.
If fewer initializers are provided, the remaining elements are zero-initialized. (i.e. Uninitialized elements are filled with <code>0</code> only if((충족)한다면) at least one initializer is provided.)
If the size is omitted, it is inferred from the number of initializers.</p></blockquote>
<hr>
<p><strong>Access and Modification Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>scores[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">85</span>;                     <span style="color:#75715e">// update value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, scores[<span style="color:#ae81ff">1</span>]);           <span style="color:#75715e">// access value
</span></span></span></code></pre></div><blockquote>
<p>C allows <strong>indexed access</strong> to each element of array using square brackets <code>[]</code>.
Indexing starts at <code>0</code> (i.e., the first element is <code>arr[0]</code>, the last is <code>arr[size - 1]</code>).
Accessing an out-of-bounds index leads to <strong>undefined behavior</strong>, due to the lack of built-in bounds checking in C.</p></blockquote>
<hr>
<h3 id="123-memory-layout-and-indexing">1.2.3. Memory Layout and Indexing<a hidden class="anchor" aria-hidden="true" href="#123-memory-layout-and-indexing">#</a></h3>
<p>Arrays are stored in contiguous memory, meaning each element is placed next to the previous one. This allows for efficient computation of any element’s address using the base address and offset.</p>
<ul>
<li>The array name (scores, name, etc.) acts as a pointer to the first element.</li>
<li>A contiguous block of memory allows for efficient random(임의) access to array elements using index arithmetic.
<ul>
<li>(\text{Address of } arr[i] = \text{base_address} + (i \times \text{element_size}))</li>
<li>(\text{Address of } arr[i] = \text{base_address} + (i \times \text{sizeof(data_type)}))</li>
</ul>
</li>
<li>This property makes array element access <strong>O(1)</strong> in time complexity.</li>
</ul>
<hr>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>};
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Memory layout:
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A[<span style="color:#ae81ff">0</span>] <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">10</span>
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">1</span>] <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">20</span>
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">2</span>] <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">30</span>
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">3</span>] <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">40</span>
</span></span></code></pre></div><hr>
<h3 id="124-abstract-view-vs-concrete-view-array-adt-vs-array-in-c">1.2.4. Abstract View vs Concrete View (Array ADT vs Array in C)<a hidden class="anchor" aria-hidden="true" href="#124-abstract-view-vs-concrete-view-array-adt-vs-array-in-c">#</a></h3>
<p>| Feature                   | Array ADT (Abstract)                               | Static Array in C (Implementation)              |
|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-|&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- &mdash;&mdash;&mdash;&mdash;&mdash;&ndash;|
| <strong>Definition Level</strong>      | Logical model                                      | Language-level memory construct                 |
| <strong>Size</strong>                  | Fixed at creation (<code>create(size)</code>)                 | Fixed at declaration (compile-time constant)    |
| <strong>Element Type</strong>          | Homogeneous (same data type)                       | Must be same type (enforced by compiler)        |
| <strong>Indexing</strong>              | Must support indexed access (e.g., <code>get(i)</code>)       | Zero-based indexing with <code>arr[i]</code>               |
| <strong>Memory Layout</strong>         | Abstract – does not specify how memory is arranged | Contiguous memory layout                        |
| <strong>Bounds Checking</strong>       | Not defined (depends on implementation)            | No built-in bounds checking                     |
| <strong>Mutability</strong>            | Allows <code>set(i, value)</code> operation                   | Allows mutation via <code>arr[i] = value</code>            |
| <strong>Language Independence</strong> | Yes                                                | No (specific to C)                              |</p>
<blockquote>
<p>Arrays in C provide efficient random access due to their contiguous memory layout,<br>
but they have limitations such as a <strong>fixed size</strong> and <strong>the lack of built-in bounds checking</strong>.</p></blockquote>
<hr>
<h2 id="section-13-implementing-static-arrays-in-c">Section 1.3. Implementing Static Arrays in C<a hidden class="anchor" aria-hidden="true" href="#section-13-implementing-static-arrays-in-c">#</a></h2>
<h3 id="131-what-is-a-static-array">1.3.1. What Is a Static Array?<a hidden class="anchor" aria-hidden="true" href="#131-what-is-a-static-array">#</a></h3>
<p>A <strong>static array</strong> in C is an array whose size is known and fixed at <strong>compile time</strong>. Its memory is allocated either on the <strong>stack</strong> (for local variables) or in the <strong>data segment</strong> (for global/static variables).</p>
<blockquote>
<p>Static here(여기에서, 이 문장에서) refers to <strong>fixed-size</strong> allocation, not necessarily the use of the <code>static</code> keyword.</p></blockquote>
<hr>
<h3 id="132-declaring-and-using-static-arrays">1.3.2. Declaring and Using Static Arrays<a hidden class="anchor" aria-hidden="true" href="#132-declaring-and-using-static-arrays">#</a></h3>
<p>Declaration:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5</span>];              <span style="color:#75715e">// Declares an array of 5 integers
</span></span></span></code></pre></div><p>Initialization:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    A[i] <span style="color:#f92672">=</span> i <span style="color:#f92672">*</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Traversal:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;A[%d] = %d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, i, A[i]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Output:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>A[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>  
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>  
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>  
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">30</span>  
</span></span><span style="display:flex;"><span>A[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">40</span>
</span></span></code></pre></div><hr>
<h3 id="133-common-operations-on-static-arrays">1.3.3. Common Operations on Static Arrays<a hidden class="anchor" aria-hidden="true" href="#133-common-operations-on-static-arrays">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Operation</th>
          <th>Code Example</th>
          <th>Time Complexity</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Access</td>
          <td><code>x = A[3];</code></td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>Update</td>
          <td><code>A[2] = 99;</code></td>
          <td>O(1)</td>
      </tr>
      <tr>
          <td>Traverse</td>
          <td>for loop with indexing</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>Search</td>
          <td>Linear search via loop</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>Insert/Shift</td>
          <td>Manual shifting needed</td>
          <td>O(n)</td>
      </tr>
      <tr>
          <td>Delete</td>
          <td>Simulate or shift</td>
          <td>O(n)</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="134-example-linear-search-in-static-array">1.3.4. Example: Linear Search in Static Array<a hidden class="anchor" aria-hidden="true" href="#134-example-linear-search-in-static-array">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> A[], <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> key) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (A[i] <span style="color:#f92672">==</span> key)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;  <span style="color:#75715e">// not found
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><hr>
<h3 id="135-limitations-of-static-arrays">1.3.5. Limitations of Static Arrays<a hidden class="anchor" aria-hidden="true" href="#135-limitations-of-static-arrays">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Limitation</th>
          <th>Explanation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Fixed size</td>
          <td>Cannot grow/shrink at runtime</td>
      </tr>
      <tr>
          <td>No insert/delete</td>
          <td>Requires manual element shifting</td>
      </tr>
      <tr>
          <td>Memory waste or overflow</td>
          <td>Over-allocation wastes memory; under-allocation causes limits</td>
      </tr>
      <tr>
          <td>No boundary check</td>
          <td>Accessing invalid index causes undefined behavior</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>Summary</strong><br>
Static arrays in C are efficient for fixed-size data with known limits.<br>
They provide fast access but lack dynamic features like resizing or safe insert/delete.</p>
<hr>
<h2 id="section-14-memory-model-and-pointer-behavior-in-arrays">Section 1.4. Memory Model and Pointer Behavior in Arrays<a hidden class="anchor" aria-hidden="true" href="#section-14-memory-model-and-pointer-behavior-in-arrays">#</a></h2>
<h3 id="141-memory-model-of-arrays">1.4.1. Memory Model of Arrays<a hidden class="anchor" aria-hidden="true" href="#141-memory-model-of-arrays">#</a></h3>
<p>In C, arrays are stored in <strong>contiguous memory locations</strong>, which means that all elements are laid out one after another in memory without any gaps.</p>
<p><strong>Example:</strong>
Given:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">4</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>};
</span></span></code></pre></div><p>The memory layout might look like:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Address</th>
          <th style="text-align: center">Content</th>
          <th style="text-align: center">Index</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><code>0x1000</code></td>
          <td style="text-align: center"><code>10</code></td>
          <td style="text-align: center"><code>A[0]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1004</code></td>
          <td style="text-align: center"><code>20</code></td>
          <td style="text-align: center"><code>A[1]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1008</code></td>
          <td style="text-align: center"><code>30</code></td>
          <td style="text-align: center"><code>A[2]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x100C</code></td>
          <td style="text-align: center"><code>40</code></td>
          <td style="text-align: center"><code>A[3]</code></td>
      </tr>
  </tbody>
</table>
<p>If <code>int</code> is 4 bytes, then the address of <code>A[i]</code> is computed as:
base_address + (i × sizeof(int))</p>
<p>This direct computation allows constant-time access: <strong>O(1)</strong>.</p>
<hr>
<h3 id="142-array-name-as-a-pointer">1.4.2. Array Name as a Pointer<a hidden class="anchor" aria-hidden="true" href="#142-array-name-as-a-pointer">#</a></h3>
<p>In most contexts, the name of an array behaves like a pointer to its first element.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> A;
</span></span></code></pre></div><p>Here:</p>
<ul>
<li><code>A</code> is automatically converted to <code>&amp;A[0]</code></li>
<li><code>p</code> now points to the first element of array <code>A</code></li>
<li><code>p[1]</code> is equivalent to <code>*(p + 1)</code> and to <code>A[1]</code></li>
</ul>
<blockquote>
<p>However, <strong><code>A</code> is not a pointer variable</strong>; it&rsquo;s a symbolic name for the array and cannot be reassigned like a pointer.</p></blockquote>
<hr>
<h3 id="143-pointer-arithmetic-on-arrays">1.4.3. Pointer Arithmetic on Arrays<a hidden class="anchor" aria-hidden="true" href="#143-pointer-arithmetic-on-arrays">#</a></h3>
<p>You can perform pointer arithmetic using array names or pointer variables:</p>
<p><strong>Examples:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">*</span>(A <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)      <span style="color:#75715e">// same as A[2]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>(p <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>)      <span style="color:#75715e">// same as p[2]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>(A <span style="color:#f92672">+</span> i)      <span style="color:#75715e">// equivalent to A[i]
</span></span></span></code></pre></div><p>You can also iterate over an array using a pointer:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#f92672">*</span>(ptr <span style="color:#f92672">+</span> i));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="144-differences-between-arrays-and-pointers">1.4.4. Differences Between Arrays and Pointers<a hidden class="anchor" aria-hidden="true" href="#144-differences-between-arrays-and-pointers">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Aspect</th>
          <th>Array</th>
          <th>Pointer</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Modifiability</td>
          <td>Cannot be reassigned</td>
          <td>Can be reassigned</td>
      </tr>
      <tr>
          <td>sizeof operator</td>
          <td>Size of entire array</td>
          <td>Size of pointer (e.g., 8 bytes)</td>
      </tr>
      <tr>
          <td>Memory allocation</td>
          <td>Contiguous block</td>
          <td>Points to any address</td>
      </tr>
      <tr>
          <td>Storage duration</td>
          <td>Stack or data segment</td>
          <td>Stack, heap, or data segment</td>
      </tr>
  </tbody>
</table>
<p><strong>Example:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sizeof</span>(A) <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">20</span> (<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">int</span> is <span style="color:#ae81ff">4</span> bytes)  
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">sizeof</span>(p) <span style="color:#960050;background-color:#1e0010">→</span> <span style="color:#ae81ff">8</span> (on <span style="color:#ae81ff">64</span><span style="color:#f92672">-</span>bit machine)
</span></span></code></pre></div><hr>
<p><strong>Summary</strong></p>
<ul>
<li>Arrays are stored in contiguous memory and support fast indexed access.</li>
<li>In most contexts, an array name acts like a pointer to the first element.</li>
<li>However, arrays and pointers are <strong>not the same</strong>, and knowing the differences is essential to avoid memory errors.</li>
</ul>
<blockquote>
<p><a href="#section-19-arrays-vs-pointers-in-c">More about pointer and array</a></p></blockquote>
<hr>
<h2 id="section-15-multidimensional-arrays">Section 1.5. Multidimensional Arrays<a hidden class="anchor" aria-hidden="true" href="#section-15-multidimensional-arrays">#</a></h2>
<h3 id="151-what-is-a-multidimensional-array">1.5.1. What Is a Multidimensional Array?<a hidden class="anchor" aria-hidden="true" href="#151-what-is-a-multidimensional-array">#</a></h3>
<p>A <strong>multidimensional array</strong> is an array of arrays. In C, the most common type is the <strong>two-dimensional array</strong> (2D array), which can be visualized as a <strong>table</strong> or <strong>matrix</strong> with rows and columns.</p>
<p>Declaration syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>type array_name[rows][columns];
</span></span></code></pre></div><p>Example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> matrix[<span style="color:#ae81ff">3</span>][<span style="color:#ae81ff">4</span>];   <span style="color:#75715e">// 3 rows, 4 columns
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// This creates a contiguous memory block to store 12 integers (3 × 4 = 12).
</span></span></span></code></pre></div><hr>
<h3 id="152-memory-layout">1.5.2. Memory Layout<a hidden class="anchor" aria-hidden="true" href="#152-memory-layout">#</a></h3>
<p>Even though a 2D array is written as a table, it is stored <strong>linearly in row-major order</strong> in memory.</p>
<p>Example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">2</span>][<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>},
</span></span><span style="display:flex;"><span>    {<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Memory layout:</p>
<table>
  <thead>
      <tr>
          <th style="text-align: center">Address</th>
          <th style="text-align: center">Value</th>
          <th style="text-align: center">Index</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><code>0x1000</code></td>
          <td style="text-align: center"><code>1</code></td>
          <td style="text-align: center"><code>A[0][0]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1004</code></td>
          <td style="text-align: center"><code>2</code></td>
          <td style="text-align: center"><code>A[0][1]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1008</code></td>
          <td style="text-align: center"><code>3</code></td>
          <td style="text-align: center"><code>A[0][2]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x100C</code></td>
          <td style="text-align: center"><code>4</code></td>
          <td style="text-align: center"><code>A[1][0]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1010</code></td>
          <td style="text-align: center"><code>5</code></td>
          <td style="text-align: center"><code>A[1][1]</code></td>
      </tr>
      <tr>
          <td style="text-align: center"><code>0x1014</code></td>
          <td style="text-align: center"><code>6</code></td>
          <td style="text-align: center"><code>A[1][2]</code></td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>If <code>int</code> is 4 bytes, each element takes 4 bytes, and rows are stored one after another.</p></blockquote>
<hr>
<h3 id="153-accessing-elements">1.5.3. Accessing Elements<a hidden class="anchor" aria-hidden="true" href="#153-accessing-elements">#</a></h3>
<p>To access a specific element:
<code>A[i][j]</code>   → element in the ith row and jth column</p>
<p>Example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>A[<span style="color:#ae81ff">1</span>][<span style="color:#ae81ff">2</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">99</span>;        <span style="color:#75715e">// sets the last element to 99
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, A[<span style="color:#ae81ff">0</span>][<span style="color:#ae81ff">1</span>]); <span style="color:#75715e">// prints 2, int A[2][3] = { {1, 2, 3}, {4, 5, 99} };
</span></span></span></code></pre></div><hr>
<h3 id="154-traversing-a-2d-array">1.5.4. Traversing a 2D Array<a hidden class="anchor" aria-hidden="true" href="#154-traversing-a-2d-array">#</a></h3>
<p>Nested loops are commonly used:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> rows; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; j <span style="color:#f92672">&lt;</span> cols; j<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d &#34;</span>, A[i][j]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="155-common-pitfalls">1.5.5. Common Pitfalls<a hidden class="anchor" aria-hidden="true" href="#155-common-pitfalls">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Mistake</th>
          <th>Explanation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Omitting column size</td>
          <td><code>int A[][3]</code> is valid, but <code>int A[][]</code> is invalid</td>
      </tr>
      <tr>
          <td>Assuming A[i][j] = A[j][i]</td>
          <td>Only symmetric for square matrices (not always true)</td>
      </tr>
      <tr>
          <td>Using wrong dimensions</td>
          <td>Declaring <code>A[3][2]</code> and accessing <code>A[2][3]</code> → undefined behavior</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>In function parameters, the <strong>number of columns must be specified</strong>, because row size alone isn&rsquo;t enough to compute addresses.</p></blockquote>
<hr>
<p><strong>Summary</strong></p>
<ul>
<li>Multidimensional arrays store data in a <strong>row-major linear memory block</strong>.</li>
<li>Access is done via multiple indices (e.g., <code>A[i][j]</code>).</li>
<li>Column size is essential for correct memory calculations.</li>
<li>Useful for matrices, grids, tables, and more.</li>
</ul>
<hr>
<h2 id="section-16-dynamic-resizable-arrays-in-c">Section 1.6. Dynamic (Resizable) Arrays in C<a hidden class="anchor" aria-hidden="true" href="#section-16-dynamic-resizable-arrays-in-c">#</a></h2>
<h3 id="161-motivation">1.6.1. Motivation<a hidden class="anchor" aria-hidden="true" href="#161-motivation">#</a></h3>
<p>C arrays are fixed-size by default. Once an array is declared with a specific size, it cannot be resized.</p>
<p>However, many real-world applications require:</p>
<ul>
<li><strong>Variable-sized</strong> inputs (e.g., user input, file contents)</li>
<li><strong>Dynamic</strong> data growth (e.g., appending items)</li>
</ul>
<p>This is where dynamic memory allocation becomes necessary.</p>
<hr>
<h3 id="162-allocating-dynamic-arrays">1.6.2. Allocating Dynamic Arrays<a hidden class="anchor" aria-hidden="true" href="#162-allocating-dynamic-arrays">#</a></h3>
<p>C provides the <code>&lt;stdlib.h&gt;</code> library functions for memory allocation:</p>
<ul>
<li><code>malloc(size)</code> – allocate uninitialized memory</li>
<li><code>calloc(n, size)</code> – allocate and zero-initialize memory</li>
<li><code>realloc(ptr, new_size)</code> – resize previously allocated memory</li>
<li><code>free(ptr)</code> – release allocated memory</li>
</ul>
<p>Example: Allocating an int array for <code>n</code> elements</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(n <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (arr <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Memory allocation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><hr>
<h3 id="163-using-and-resizing">1.6.3. Using and Resizing<a hidden class="anchor" aria-hidden="true" href="#163-using-and-resizing">#</a></h3>
<p>To access elements:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>arr[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>arr[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">20</span>;
</span></span></code></pre></div><p>To resize (e.g., double the size):</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span>arr <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">realloc</span>(arr, n <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (arr <span style="color:#f92672">==</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;Reallocation failed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">exit</span>(<span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>To release memory when done:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#a6e22e">free</span>(arr);
</span></span></code></pre></div><hr>
<h3 id="164-benefits-and-risks">1.6.4. Benefits and Risks<a hidden class="anchor" aria-hidden="true" href="#164-benefits-and-risks">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Benefit</th>
          <th>Risk</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Can grow or shrink at runtime</td>
          <td>Manual memory management required</td>
      </tr>
      <tr>
          <td>Efficient use of memory</td>
          <td>Forgetting <code>free()</code> causes memory leaks</td>
      </tr>
      <tr>
          <td>Flexible for input size</td>
          <td>Dangling pointers if misused</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="165-comparison-with-static-arrays">1.6.5. Comparison with Static Arrays<a hidden class="anchor" aria-hidden="true" href="#165-comparison-with-static-arrays">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Static Array</th>
          <th>Dynamic Array</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Size</td>
          <td>Fixed at compile time</td>
          <td>Determined at runtime</td>
      </tr>
      <tr>
          <td>Memory</td>
          <td>Stack or data segment</td>
          <td>Heap (via malloc, realloc)</td>
      </tr>
      <tr>
          <td>Flexibility</td>
          <td>Inflexible</td>
          <td>Resizable</td>
      </tr>
      <tr>
          <td>Bounds checking</td>
          <td>Not provided</td>
          <td>Still not provided</td>
      </tr>
      <tr>
          <td>Lifetime</td>
          <td>Automatic (if local)</td>
          <td>Manual malloc/free needed</td>
      </tr>
  </tbody>
</table>
<hr>
<p><strong>Summary</strong></p>
<ul>
<li>C does not support built-in dynamic arrays like higher-level languages.</li>
<li>You must use heap allocation functions like malloc() and realloc().</li>
<li>Always call free() to prevent memory leaks.</li>
<li>Dynamic arrays are essential for variable-size data.</li>
</ul>
<hr>
<h2 id="section-17-limitations-of-arrays-and-why-linked-lists-are-needed">Section 1.7. Limitations of Arrays and Why Linked Lists Are Needed<a hidden class="anchor" aria-hidden="true" href="#section-17-limitations-of-arrays-and-why-linked-lists-are-needed">#</a></h2>
<h3 id="171-limitations-of-static-and-dynamic-arrays">1.7.1. Limitations of Static and Dynamic Arrays<a hidden class="anchor" aria-hidden="true" href="#171-limitations-of-static-and-dynamic-arrays">#</a></h3>
<p>Although arrays are efficient for indexed access, they have several limitations that make them less suitable for certain use cases:</p>
<table>
  <thead>
      <tr>
          <th>Limitation</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Fixed Size (Static)</td>
          <td>Static arrays cannot grow or shrink; their size is fixed at compile time.</td>
      </tr>
      <tr>
          <td>Manual Resizing</td>
          <td>Dynamic arrays require manual resizing using realloc(), which is costly.</td>
      </tr>
      <tr>
          <td>Costly Insertion</td>
          <td>Inserting an element in the middle requires shifting all subsequent items.</td>
      </tr>
      <tr>
          <td>Costly Deletion</td>
          <td>Similarly, deletion also requires shifting elements to fill the gap.</td>
      </tr>
      <tr>
          <td>Fragmentation Risk</td>
          <td>realloc() may move the array in memory, breaking previous pointers.</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="172-use-case-example-inserting-at-the-beginning">1.7.2. Use Case Example: Inserting at the Beginning<a hidden class="anchor" aria-hidden="true" href="#172-use-case-example-inserting-at-the-beginning">#</a></h3>
<p>Suppose we want to insert an element at the front of an array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">40</span>, <span style="color:#ae81ff">50</span>};
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Insert 5 at A[0]; shift all elements
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>; i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">--</span>) {
</span></span><span style="display:flex;"><span>        A[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> A[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    A[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span></code></pre></div><p>This process is O(n) due to the shifting. If we frequently insert or delete at arbitrary positions, arrays are inefficient.</p>
<hr>
<h3 id="173-why-linked-lists-help">1.7.3. Why Linked Lists Help<a hidden class="anchor" aria-hidden="true" href="#173-why-linked-lists-help">#</a></h3>
<p><strong>Linked lists</strong> solve many of the above issues by using nodes and pointers rather than contiguous memory.</p>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Array</th>
          <th>Linked List</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Size Flexibility</td>
          <td>Fixed (or manually resized)</td>
          <td>Grows or shrinks dynamically</td>
      </tr>
      <tr>
          <td>Insertion/Deletion</td>
          <td>Costly (shift required)</td>
          <td>Efficient at head or tail</td>
      </tr>
      <tr>
          <td>Memory Layout</td>
          <td>Contiguous</td>
          <td>Non-contiguous (each node separate)</td>
      </tr>
      <tr>
          <td>Random Access</td>
          <td>O(1)</td>
          <td>O(n) (must traverse)</td>
      </tr>
      <tr>
          <td>Memory Overhead</td>
          <td>Low</td>
          <td>Higher (pointer + data per node)</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="174-when-to-choose-linked-lists">1.7.4. When to Choose Linked Lists<a hidden class="anchor" aria-hidden="true" href="#174-when-to-choose-linked-lists">#</a></h3>
<p>Linked lists are preferred when:</p>
<ul>
<li>The number of elements is unknown or changes frequently.</li>
<li>Frequent insertions/deletions are expected at arbitrary positions.</li>
<li>Memory fragmentation is not a concern.</li>
</ul>
<blockquote>
<p>Note: Arrays are still preferable when fast indexing and low memory overhead are important.</p></blockquote>
<hr>
<h3 id="175-summary">1.7.5. Summary<a hidden class="anchor" aria-hidden="true" href="#175-summary">#</a></h3>
<ul>
<li>Arrays are simple and fast for indexed data access but become inefficient for frequent structural changes.</li>
<li>Linked lists offer better flexibility at the cost of pointer overhead and slower access.</li>
<li>Understanding their trade-offs is crucial before choosing one over the other.</li>
</ul>
<hr>
<h2 id="section-18-arrays-vs-pointers-in-c">Section 1.8. Arrays vs Pointers in C<a hidden class="anchor" aria-hidden="true" href="#section-18-arrays-vs-pointers-in-c">#</a></h2>
<h3 id="181-conceptual-difference">1.8.1. Conceptual Difference<a hidden class="anchor" aria-hidden="true" href="#181-conceptual-difference">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Feature</th>
          <th>Array</th>
          <th>Pointer</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Definition</td>
          <td>Collection of fixed-size, contiguous elements</td>
          <td>Variable storing the address of another variable</td>
      </tr>
      <tr>
          <td>Memory Allocation</td>
          <td>Automatically allocates a block of memory</td>
          <td>Must be explicitly assigned or allocated</td>
      </tr>
      <tr>
          <td>Reassignability</td>
          <td>Cannot reassign the array variable itself</td>
          <td>Pointer can be reassigned to another location</td>
      </tr>
      <tr>
          <td>Syntax</td>
          <td><code>int A[10];</code></td>
          <td><code>int *p;</code> and <code>p = A;</code> or <code>p = malloc()</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="182-array-name-as-a-pointer-when-and-how">1.8.2. Array Name as a Pointer (When and How)<a hidden class="anchor" aria-hidden="true" href="#182-array-name-as-a-pointer-when-and-how">#</a></h3>
<p>In most expressions, the name of an array is converted to a pointer to its first element:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">3</span>] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> A;        <span style="color:#75715e">// p points to A[0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">*</span>(A <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>));  <span style="color:#75715e">// prints 2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, p[<span style="color:#ae81ff">2</span>]);      <span style="color:#75715e">// prints 3
</span></span></span></code></pre></div><blockquote>
<p>Both <code>A[i]</code> and <code>*(A + i)</code> are valid and equivalent.
However:
<code>A = p;</code> is illegal (you can’t assign to an array name)
<code>p = A;</code> is legal (you can assign an array address to a pointer)</p></blockquote>
<hr>
<h3 id="183-sizeof-operator-difference">1.8.3. sizeof Operator Difference<a hidden class="anchor" aria-hidden="true" href="#183-sizeof-operator-difference">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> A[<span style="color:#ae81ff">5</span>];
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> A;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%zu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">sizeof</span>(A)); <span style="color:#75715e">// Output: 20 (if int = 4 bytes)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%zu</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, <span style="color:#66d9ef">sizeof</span>(p)); <span style="color:#75715e">// Output: 8 (on 64-bit systems)
</span></span></span></code></pre></div><blockquote>
<p><code>sizeof(A)</code> = total memory size allocated for the array
<code>sizeof(p)</code> = size of a pointer (not the array contents)</p></blockquote>
<hr>
<h3 id="184-pointer-arithmetic-and-access">1.8.4. Pointer Arithmetic and Access<a hidden class="anchor" aria-hidden="true" href="#184-pointer-arithmetic-and-access">#</a></h3>
<p>Both arrays and pointers support arithmetic operations like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">*</span>(p <span style="color:#f92672">+</span> i), A[i], p[i]
</span></span></code></pre></div><p>However, only pointers can be incremented:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>p<span style="color:#f92672">++</span>;       <span style="color:#75715e">// valid
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>A<span style="color:#f92672">++</span>;       <span style="color:#75715e">// invalid (compile error)
</span></span></span></code></pre></div><hr>
<h3 id="185-function-parameter-behavior">1.8.5. Function Parameter Behavior<a hidden class="anchor" aria-hidden="true" href="#185-function-parameter-behavior">#</a></h3>
<p>When passing an array to a function, it decays to a pointer.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> A[]) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// A is actually of type int*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">foo</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>A) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Equivalent declaration
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Therefore, you lose the size information unless it’s passed separately.</p>
<hr>
<h3 id="186-summary">1.8.6. Summary<a hidden class="anchor" aria-hidden="true" href="#186-summary">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Aspect</th>
          <th>Array</th>
          <th>Pointer</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Syntax</td>
          <td><code>int A[10];</code></td>
          <td><code>int *p = A;</code></td>
      </tr>
      <tr>
          <td>Memory</td>
          <td>Allocated at declaration</td>
          <td>Can be dynamic (via malloc)</td>
      </tr>
      <tr>
          <td>Reassignment</td>
          <td>Not allowed (<code>A = ...</code>)</td>
          <td>Allowed (<code>p = ...</code>)</td>
      </tr>
      <tr>
          <td>sizeof Operator</td>
          <td>Total memory of all elements</td>
          <td>Size of the pointer itself</td>
      </tr>
      <tr>
          <td>Arithmetic</td>
          <td>Limited (<code>A++</code> illegal)</td>
          <td>Full pointer arithmetic allowed</td>
      </tr>
      <tr>
          <td>Function Parameter Form</td>
          <td>Decays to pointer</td>
          <td>Naturally a pointer</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p><strong>Conclusion:</strong>
Arrays and pointers in C share similar behaviors in terms of element access, but they are fundamentally different entities. Understanding their differences is crucial for safe memory manipulation and efficient programming in C.</p></blockquote>
<hr>
<p><strong>References</strong></p>
<ul>
<li>Kernighan &amp; Ritchie, <em>The C Programming Language</em>, 2nd Edition</li>
<li>ISO/IEC 9899:1999</li>
<li>CS50: Pointers and Memory Layout</li>
<li>GeeksforGeeks: <a href="https://www.geeksforgeeks.org/arrays-in-c-cpp/">Static Arrays in C</a></li>
</ul>
<hr>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://Byngjoon.github.io/blog/tags/data-structures/">Data Structures</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://Byngjoon.github.io/blog/">Hyungtae</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
