<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>[Data Structures] [00] Introduction to Data Structures | Hyungtae</title>
<meta name="keywords" content="Data Structures">
<meta name="description" content="The preface and core concepts of Data Structures series">
<meta name="author" content="">
<link rel="canonical" href="https://Byngjoon.github.io/blog/posts/introduction-to-data-structures/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css" integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF&#43;13Dyqob6ASlTrTye8=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://Byngjoon.github.io/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://Byngjoon.github.io/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://Byngjoon.github.io/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://Byngjoon.github.io/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://Byngjoon.github.io/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://Byngjoon.github.io/blog/posts/introduction-to-data-structures/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
<script>
  window.onload = function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false }
      ]
    });
  };
</script>

<meta property="og:url" content="https://Byngjoon.github.io/blog/posts/introduction-to-data-structures/">
  <meta property="og:site_name" content="Hyungtae">
  <meta property="og:title" content="[Data Structures] [00] Introduction to Data Structures">
  <meta property="og:description" content="The preface and core concepts of Data Structures series">
  <meta property="og:locale" content="ko-kr">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2025-05-17T07:20:49+09:00">
    <meta property="article:modified_time" content="2025-05-17T07:20:49+09:00">
    <meta property="article:tag" content="Data Structures">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Data Structures] [00] Introduction to Data Structures">
<meta name="twitter:description" content="The preface and core concepts of Data Structures series">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://Byngjoon.github.io/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "[Data Structures] [00] Introduction to Data Structures",
      "item": "https://Byngjoon.github.io/blog/posts/introduction-to-data-structures/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "[Data Structures] [00] Introduction to Data Structures",
  "name": "[Data Structures] [00] Introduction to Data Structures",
  "description": "The preface and core concepts of Data Structures series",
  "keywords": [
    "Data Structures"
  ],
  "articleBody": "Chapter 00. Introduction to Data Structures Outline: This chapter provides a foundational overview of what data structures are, how they differ from data types, and why Abstract Data Types (ADTs) are essential. It also introduces basic C language concepts that are prerequisites(사전에 필요한) for understanding and implementing data structures.\nContents 0.1. What is Data Structures about? 0.2. Data Type vs Data Structure 0.3. What is an Abstract Data Type (ADT)? 0.4. C Language Essentials for Data Structures Section 0.1. What is Data Structures about? Data Structures is the study of how to organize, store, and manage data efficiently in a computer system.\nIt focuses on designing ways to:\nStore data (structure) How to structure data (Arrays, Linked Lists, Trees, Graphs, Hash Tables, etc.)\nAccess and modify data (operations) How to insert, delete, search, sort, and traverse data\nOptimize performance (time \u0026 space complexity) Measuring performance using time \u0026 space complexity (Big-O notation) Choosing the right data structure for different problems (e.g., using stacks for undo history)\nClassification of Data Structures 1. By Structural Form Type Description Examples Linear Structure Data elements are arranged sequentially Array, Linked List, Stack, Queue Non-linear Structure Data elements have hierarchical(계층적인) or graph-like relationships Tree, Graph, Heap Hash-based Structure Data is accessed via keys and hash functions Hash Table, Hash Map, Hash Set 2. By Storage Method Type Description Examples Sequential Storage Data is stored in contiguous memory Array, Static Queue Linked Storage Nodes are connected via pointers Linked List, Tree, Graph Indexed Storage Access is based on key/index positions Hash Table, Skip List, B-Tree 3. By Access Method Type Description Examples Random Access Direct access using index/key Array, Hash Table Sequential Access Access data in order, one by one Linked List, Queue Hierarchical Access Access through parent-child relationships Tree, Heap Unstructured Access Access based on arbitrary connections Graph Why Do We Learn Data Structures? To solve problems efficiently and reliably.\nEven with a good algorithm, choosing the wrong data structure can waste time and memory resources.\nProblem Scenario Recommended Data Structure Fast search Hash Map Frequent insertions/removals Linked List Undo feature Stack Ordered access Array, List Section 0.2. Data Type vs Data Structure Data Type: Defines the form and allowed operations for a single piece of data.\nint: Represents a single integer value; supports arithmetic(산술) operations like addition, subtraction, etc. char: Represents a single character; supports character encoding operations (e.g., ASCII manipulation) Data Structure: Organizes, stores, accesses, and manages a collection of data.\nArray: Stores elements in contiguous(인접한) memory locations Linked List: Connects nodes using pointers to form a linear structure Aspect Data Type Data Structure Purpose Define the kind of a single value Organize and manage a group of related values Examples int, float, char, etc. Array, Stack, Queue, Linked List, etc. Unit A single value A collection of values Focus The data itself The relationship and operations among data Section 0.3. What is an Abstract Data Type (ADT)? An Abstract Data Type (ADT) defines a logical model (object) and a set of operations for handling data, while hiding the internal implementation details(구현 상세).\nWe can see what it does (interface). We cannot see how it works (implementation). Therefore, users can use an ADT without knowing its internal mechanism. ADT Must Define Two Components Component Description Object The type of data being handled (e.g., integers, a set of characters, etc.) Collection of Operations The set of valid actions to perform on the data (insert, delete, search, etc.) Examples of ADTs 1. Stack ADT Component Description Object A collection of ordered elements (e.g., integers, characters, etc.) Operations push(x), pop(), peek(), isEmpty(), … Characteristics Follows LIFO (Last-In, First-Out) principle; the most recently added element is removed first The stack can be implemented using an array or a linked list,\nbut the user only needs to know the interface, not the implementation.\n2. Queue ADT Component Description Object A linear collection representing a waiting line Operations enqueue(x), dequeue(), front(), isEmpty(), … Characteristics Follows FIFO (First-In, First-Out) principle; the earliest added element is removed first 3. List ADT Component Description Object A sequence of elements with index-based access Operations insert(i, x), delete(i), get(i), find(x), … Characteristics Supports indexed access; can be implemented with arrays or linked structures ADT vs Data Structure Aspect ADT (Abstract Data Type) Data Structure Perspective Conceptual interface (what it does) Concrete implementation (how it works) Examples Stack, Queue, List Array, Linked List, Tree, Hash Table Focus What operations are supported How those operations are implemented efficiently Purpose Provide a simple and clear interface to users Optimize performance through implementation choices Why Do We Use ADTs? Abstraction\nUsers can use data structures without knowing internal details.\nModularity (Flexibility)\nIf the ADT interface remains the same, the internal implementation can be changed without affecting user code.\nReusability\nADT-based designs can be reused in various problem domains with minimal modification.\nData Protection\nThe internal state is hidden, so users cannot tamper with it directly, ensuring consistency and integrity.\nIn summary:\nAn ADT defines what data and operations are available, not how they are performed.\nThis separation allows for clean, maintainable, and flexible software design.\nSection 0.4. C Language Essentials for Data Structures We will implement data structures using the C programming language.\nTo do this effectively, we need to understand three core concepts:\nWhat is a struct type in C? How do we use pointers in C? How do we perform dynamic memory allocation in C? What is struct type in C? A struct (short for structure) in C is a user-defined data type that allows you to group variables of different types under a single name.\nUnlike arrays, which access elements by index, a struct uses named fields to access its internal data.\nTo access these fields, you use the dot operator (.).\nExample: struct Node { // 'Node' is the struct type name int data; // field struct Node* next; // field }; struct Node node1; node1.data = 10; // Accessing the 'data' field using the dot operator Memory Allocation of ‘struct’ Type A struct is stored in a contiguous block of memory, and its fields are laid out in the order they are declared. However, the total memory size of a struct may be larger than the sum of its fields’ sizes due to: Padding: extra space inserted between fields Alignment rules: used to optimize memory access performance on most architectures You can check the actual memory allocated for a struct using sizeof(struct) in C. These rules ensure that each field starts at a memory address aligned to its size (e.g., int on 4-byte boundaries, double on 8-byte boundaries).\nExample: struct studentInfo { char name[10]; int age; double gpa; }; Field Type Size (bytes) Memory Offset Notes name char[10] 10 0–9 Starts at offset 0 padding — 2 10–11 To align int to a 4-byte boundary age int 4 12–15 4-byte aligned gpa double 8 16–23 8-byte aligned total — 24 bytes — sizeof(struct studentInfo) == 24 ’typedef’ in C typedef is used to assign a custom alias(별칭) to an existing type. It helps simplify complex type names and improve code readability, especially with struct. Example // typedef typedef struct Node { // 'Node' is the struct tag int data; struct Node* next; } Node; // 'Node' is now a type alias typedef struct { char name[10]; int age; double gpa; } studentInfo; // Anonymous struct with alias 'studentInfo' Node node1; studentInfo s1; In this example: Node can now be used like a built-in type to declare variables studentInfo represents a structure without an explicit tag name\nHow Do We Use Pointers in C? A pointer is a variable that stores the memory address of another variable.\nBasic Pointer Example int a = 10; int *p; // Declare a pointer to an int p = \u0026a; // '\u0026' (address-of operator): gets the address of variable 'a' *p = 11; // '*' (dereference operator): access or modify the value pointed to by 'p' Type-Specific Pointer Examples double *pf; // pf points to a double variable char *pc; // pc points to a char variable double **ppf; // ppf is a pointer to a pointer to a double char *ppc[]; // ppc is an array of pointers to char (e.g., array of strings) Pointer arithmetic depends on the size of the data type.\nFor example, pf + 1 increases the address by sizeof(double) (typically 8 bytes),\nwhile pc + 1 increases by sizeof(char) (1 byte).\nSpecial Types of Pointers Type Description NULL Pointer A pointer that doesn’t point to any valid memory location (used for safety checks) void * Pointer (Generic Pointer) A pointer that can hold the address of any data type. It cannot be directly dereferenced without type casting, but can be automatically cast during assignment. void *vp; int x = 5; vp = \u0026x; // okay: implicit cast to void* printf(\"%d\", *(int *)vp); // must cast back to correct type to dereference Summary * is used to declare a pointer and to dereference it. \u0026 gives the address of a variable. Pointers are powerful tools in C, essential for dynamic memory, arrays, structs, and efficient data structures. How Do We Perform Dynamic Memory Allocation in C? Dynamic memory allocation means allocating memory during the execution of a program (at runtime), rather than at compile time.\nMemory is allocated as needed, and can be released once no longer required. This enables efficient memory usage, especially for data structures with variable size (e.g., linked lists, trees, etc.). Basic Example #include int *p; p = (int *)malloc(sizeof(int)); // malloc returns void*, so explicit type casting is needed in C if (p != NULL) { *p = 10; // assigning value to dynamically allocated memory } free(p); // Always free allocated memory after use to prevent memory leaks Key Functions in stdlib.h Function Purpose malloc(size) Allocates uninitialized memory of size bytes calloc(n, size) Allocates memory for n elements and initializes all to zero realloc(ptr, new_size) Resizes previously allocated memory block free(ptr) Frees the memory previously allocated by malloc, calloc, or realloc Notes Always check if malloc() or calloc() returns NULL (allocation failed). Memory leaks can occur if free() is forgotten. Memory allocated with malloc() remains until manually freed. ",
  "wordCount" : "1695",
  "inLanguage": "en",
  "datePublished": "2025-05-17T07:20:49+09:00",
  "dateModified": "2025-05-17T07:20:49+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://Byngjoon.github.io/blog/posts/introduction-to-data-structures/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Hyungtae",
    "logo": {
      "@type": "ImageObject",
      "url": "https://Byngjoon.github.io/blog/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://Byngjoon.github.io/blog/" accesskey="h" title="Hyungtae (Alt + H)">Hyungtae</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://Byngjoon.github.io/blog/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://Byngjoon.github.io/blog/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      [Data Structures] [00] Introduction to Data Structures
    </h1>
    <div class="post-description">
      The preface and core concepts of Data Structures series
    </div>
    <div class="post-meta"><span title='2025-05-17 07:20:49 +0900 KST'>May 17, 2025</span>&nbsp;·&nbsp;8 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#chapter-00-introduction-to-data-structures" aria-label="Chapter 00. Introduction to Data Structures">Chapter 00. Introduction to Data Structures</a><ul>
                        
                <li>
                    <a href="#contents" aria-label="Contents">Contents</a></li>
                <li>
                    <a href="#section-01-what-is-data-structures-about" aria-label="Section 0.1. What is Data Structures about?">Section 0.1. What is Data Structures about?</a><ul>
                        
                <li>
                    <a href="#classification-of-data-structures" aria-label="Classification of Data Structures">Classification of Data Structures</a><ul>
                        
                <li>
                    <a href="#1-by-structural-form" aria-label="1. By Structural Form">1. By Structural Form</a></li>
                <li>
                    <a href="#2-by-storage-method" aria-label="2. By Storage Method">2. By Storage Method</a></li>
                <li>
                    <a href="#3-by-access-method" aria-label="3. By Access Method">3. By Access Method</a></li></ul>
                </li>
                <li>
                    <a href="#why-do-we-learn-data-structures" aria-label="Why Do We Learn Data Structures?">Why Do We Learn Data Structures?</a></li></ul>
                </li>
                <li>
                    <a href="#section-02-data-type-vs-data-structure" aria-label="Section 0.2. Data Type vs Data Structure">Section 0.2. Data Type vs Data Structure</a></li>
                <li>
                    <a href="#section-03-what-is-an-abstract-data-type-adt" aria-label="Section 0.3. What is an Abstract Data Type (ADT)?">Section 0.3. What is an Abstract Data Type (ADT)?</a><ul>
                        
                <li>
                    <a href="#adt-must-define-two-components" aria-label="ADT Must Define Two Components">ADT Must Define Two Components</a><ul>
                        
                <li>
                    <a href="#examples-of-adts" aria-label="Examples of ADTs">Examples of ADTs</a><ul>
                        
                <li>
                    <a href="#1-stack-adt" aria-label="1. Stack ADT">1. Stack ADT</a></li>
                <li>
                    <a href="#2-queue-adt" aria-label="2. Queue ADT">2. Queue ADT</a></li>
                <li>
                    <a href="#3-list-adt" aria-label="3. List ADT">3. List ADT</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#adt-vs-data-structure" aria-label="ADT vs Data Structure">ADT vs Data Structure</a></li>
                <li>
                    <a href="#why-do-we-use-adts" aria-label="Why Do We Use ADTs?">Why Do We Use ADTs?</a></li></ul>
                </li>
                <li>
                    <a href="#section-04-c-language-essentials-for-data-structures" aria-label="Section 0.4. C Language Essentials for Data Structures">Section 0.4. C Language Essentials for Data Structures</a><ul>
                        
                <li>
                    <a href="#what-is-struct-type-in-c" aria-label="What is struct type in C?">What is struct type in C?</a><ul>
                        
                <li>
                    <a href="#example" aria-label="Example:">Example:</a></li>
                <li>
                    <a href="#memory-allocation-of-struct-type" aria-label="Memory Allocation of &lsquo;struct&rsquo; Type">Memory Allocation of &lsquo;struct&rsquo; Type</a><ul>
                        
                <li>
                    <a href="#example-1" aria-label="Example:">Example:</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#typedef-in-c" aria-label="&rsquo;typedef&rsquo; in C">&rsquo;typedef&rsquo; in C</a><ul>
                        
                <li>
                    <a href="#example-2" aria-label="Example">Example</a></li></ul>
                </li>
                <li>
                    <a href="#how-do-we-use-pointers-in-c" aria-label="How Do We Use Pointers in C?">How Do We Use Pointers in C?</a><ul>
                        
                <li>
                    <a href="#basic-pointer-example" aria-label="Basic Pointer Example">Basic Pointer Example</a></li>
                <li>
                    <a href="#type-specific-pointer-examples" aria-label="Type-Specific Pointer Examples">Type-Specific Pointer Examples</a></li>
                <li>
                    <a href="#special-types-of-pointers" aria-label="Special Types of Pointers">Special Types of Pointers</a></li>
                <li>
                    <a href="#summary" aria-label="Summary">Summary</a></li></ul>
                </li>
                <li>
                    <a href="#how-do-we-perform-dynamic-memory-allocation-in-c" aria-label="How Do We Perform Dynamic Memory Allocation in C?">How Do We Perform Dynamic Memory Allocation in C?</a><ul>
                        
                <li>
                    <a href="#basic-example" aria-label="Basic Example">Basic Example</a></li>
                <li>
                    <a href="#key-functions-in-stdlibh" aria-label="Key Functions in stdlib.h">Key Functions in stdlib.h</a></li>
                <li>
                    <a href="#notes" aria-label="Notes">Notes</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="chapter-00-introduction-to-data-structures">Chapter 00. Introduction to Data Structures<a hidden class="anchor" aria-hidden="true" href="#chapter-00-introduction-to-data-structures">#</a></h1>
<blockquote>
<p><strong>Outline:</strong> This chapter provides a foundational overview of what data structures are, how they differ from data types, and why Abstract Data Types (ADTs) are essential. It also introduces basic C language concepts that are prerequisites(사전에 필요한) for understanding and implementing data structures.</p></blockquote>
<hr>
<h2 id="contents">Contents<a hidden class="anchor" aria-hidden="true" href="#contents">#</a></h2>
<ul>
<li><a href="#section-01-what-is-data-structures-about">0.1. What is Data Structures about?</a></li>
<li><a href="#section-02-data-type-vs-data-structure">0.2. Data Type vs Data Structure</a></li>
<li><a href="#section-03-what-is-an-abstract-data-type-adt">0.3. What is an Abstract Data Type (ADT)?</a></li>
<li><a href="#section-04-c-language-essentials-for-data-structures">0.4. C Language Essentials for Data Structures</a></li>
</ul>
<hr>
<h2 id="section-01-what-is-data-structures-about">Section 0.1. What is Data Structures about?<a hidden class="anchor" aria-hidden="true" href="#section-01-what-is-data-structures-about">#</a></h2>
<p>Data Structures is the study of how to organize, store, and manage data <strong>efficiently</strong> in a computer system.</p>
<hr>
<p>It focuses on designing ways to:</p>
<ol>
<li>
<p>Store data (<strong>structure</strong>)
How to structure data (Arrays, Linked Lists, Trees, Graphs, Hash Tables, etc.)</p>
</li>
<li>
<p>Access and modify data (<strong>operations</strong>)
How to insert, delete, search, sort, and traverse data</p>
</li>
<li>
<p>Optimize performance (<strong>time &amp; space complexity</strong>)
Measuring performance using time &amp; space complexity (Big-O notation)
Choosing the right data structure for different problems (e.g., using stacks for undo history)</p>
</li>
</ol>
<hr>
<h3 id="classification-of-data-structures">Classification of Data Structures<a hidden class="anchor" aria-hidden="true" href="#classification-of-data-structures">#</a></h3>
<h4 id="1-by-structural-form">1. By Structural Form<a hidden class="anchor" aria-hidden="true" href="#1-by-structural-form">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Description</th>
          <th>Examples</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Linear Structure</strong></td>
          <td>Data elements are arranged sequentially</td>
          <td>Array, Linked List, Stack, Queue</td>
      </tr>
      <tr>
          <td><strong>Non-linear Structure</strong></td>
          <td>Data elements have hierarchical(계층적인) or graph-like relationships</td>
          <td>Tree, Graph, Heap</td>
      </tr>
      <tr>
          <td><strong>Hash-based Structure</strong></td>
          <td>Data is accessed via keys and hash functions</td>
          <td>Hash Table, Hash Map, Hash Set</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="2-by-storage-method">2. By Storage Method<a hidden class="anchor" aria-hidden="true" href="#2-by-storage-method">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Description</th>
          <th>Examples</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Sequential Storage</strong></td>
          <td>Data is stored in contiguous memory</td>
          <td>Array, Static Queue</td>
      </tr>
      <tr>
          <td><strong>Linked Storage</strong></td>
          <td>Nodes are connected via pointers</td>
          <td>Linked List, Tree, Graph</td>
      </tr>
      <tr>
          <td><strong>Indexed Storage</strong></td>
          <td>Access is based on key/index positions</td>
          <td>Hash Table, Skip List, B-Tree</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="3-by-access-method">3. By Access Method<a hidden class="anchor" aria-hidden="true" href="#3-by-access-method">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Description</th>
          <th>Examples</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Random Access</strong></td>
          <td>Direct access using index/key</td>
          <td>Array, Hash Table</td>
      </tr>
      <tr>
          <td><strong>Sequential Access</strong></td>
          <td>Access data in order, one by one</td>
          <td>Linked List, Queue</td>
      </tr>
      <tr>
          <td><strong>Hierarchical Access</strong></td>
          <td>Access through parent-child relationships</td>
          <td>Tree, Heap</td>
      </tr>
      <tr>
          <td><strong>Unstructured Access</strong></td>
          <td>Access based on arbitrary connections</td>
          <td>Graph</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="why-do-we-learn-data-structures">Why Do We Learn Data Structures?<a hidden class="anchor" aria-hidden="true" href="#why-do-we-learn-data-structures">#</a></h3>
<p>To solve problems <strong>efficiently</strong> and <strong>reliably</strong>.</p>
<p>Even with a good algorithm, choosing the wrong data structure can waste <strong>time</strong> and <strong>memory resources</strong>.</p>
<hr>
<table>
  <thead>
      <tr>
          <th>Problem Scenario</th>
          <th>Recommended Data Structure</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Fast search</td>
          <td>Hash Map</td>
      </tr>
      <tr>
          <td>Frequent insertions/removals</td>
          <td>Linked List</td>
      </tr>
      <tr>
          <td>Undo feature</td>
          <td>Stack</td>
      </tr>
      <tr>
          <td>Ordered access</td>
          <td>Array, List</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="section-02-data-type-vs-data-structure">Section 0.2. Data Type vs Data Structure<a hidden class="anchor" aria-hidden="true" href="#section-02-data-type-vs-data-structure">#</a></h2>
<p><strong>Data Type</strong>: Defines the form and allowed operations for a single piece of data.</p>
<ul>
<li><code>int</code>: Represents a single integer value; supports arithmetic(산술) operations like addition, subtraction, etc.</li>
<li><code>char</code>: Represents a single character; supports character encoding operations (e.g., ASCII manipulation)</li>
</ul>
<p><strong>Data Structure</strong>: Organizes, stores, accesses, and manages a <strong>collection of data</strong>.</p>
<ul>
<li><code>Array</code>: Stores elements in contiguous(인접한) memory locations</li>
<li><code>Linked List</code>: Connects nodes using pointers to form a linear structure</li>
</ul>
<table>
  <thead>
      <tr>
          <th>Aspect</th>
          <th>Data Type</th>
          <th>Data Structure</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Purpose</td>
          <td>Define the kind of a single value</td>
          <td>Organize and manage a group of related values</td>
      </tr>
      <tr>
          <td>Examples</td>
          <td><code>int</code>, <code>float</code>, <code>char</code>, etc.</td>
          <td><code>Array</code>, <code>Stack</code>, <code>Queue</code>, <code>Linked List</code>, etc.</td>
      </tr>
      <tr>
          <td>Unit</td>
          <td>A single value</td>
          <td>A collection of values</td>
      </tr>
      <tr>
          <td>Focus</td>
          <td>The data itself</td>
          <td>The relationship and operations among data</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="section-03-what-is-an-abstract-data-type-adt">Section 0.3. What is an Abstract Data Type (ADT)?<a hidden class="anchor" aria-hidden="true" href="#section-03-what-is-an-abstract-data-type-adt">#</a></h2>
<p>An <strong>Abstract Data Type (ADT)</strong> defines a logical model (object) and a set of operations for handling data, while hiding the internal implementation details(구현 상세).</p>
<ul>
<li>We can see <strong>what it does</strong> (interface).</li>
<li>We cannot see <strong>how it works</strong> (implementation).</li>
<li>Therefore, users can use an ADT <strong>without knowing its internal mechanism</strong>.</li>
</ul>
<hr>
<h3 id="adt-must-define-two-components">ADT Must Define Two Components<a hidden class="anchor" aria-hidden="true" href="#adt-must-define-two-components">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Object</strong></td>
          <td>The type of data being handled (e.g., integers, a set of characters, etc.)</td>
      </tr>
      <tr>
          <td><strong>Collection of Operations</strong></td>
          <td>The set of valid actions to perform on the data (insert, delete, search, etc.)</td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="examples-of-adts">Examples of ADTs<a hidden class="anchor" aria-hidden="true" href="#examples-of-adts">#</a></h4>
<h5 id="1-stack-adt">1. Stack ADT<a hidden class="anchor" aria-hidden="true" href="#1-stack-adt">#</a></h5>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Object</strong></td>
          <td>A collection of ordered elements (e.g., integers, characters, etc.)</td>
      </tr>
      <tr>
          <td><strong>Operations</strong></td>
          <td><code>push(x)</code>, <code>pop()</code>, <code>peek()</code>, <code>isEmpty()</code>, &hellip;</td>
      </tr>
      <tr>
          <td><strong>Characteristics</strong></td>
          <td>Follows <strong>LIFO (Last-In, First-Out)</strong> principle; the most recently added element is removed first</td>
      </tr>
  </tbody>
</table>
<blockquote>
<p>The stack can be implemented using an <strong>array</strong> or a <strong>linked list</strong>,<br>
but the user only needs to know the <strong>interface</strong>, not the implementation.</p></blockquote>
<hr>
<h5 id="2-queue-adt">2. Queue ADT<a hidden class="anchor" aria-hidden="true" href="#2-queue-adt">#</a></h5>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Object</strong></td>
          <td>A linear collection representing a waiting line</td>
      </tr>
      <tr>
          <td><strong>Operations</strong></td>
          <td><code>enqueue(x)</code>, <code>dequeue()</code>, <code>front()</code>, <code>isEmpty()</code>, &hellip;</td>
      </tr>
      <tr>
          <td><strong>Characteristics</strong></td>
          <td>Follows <strong>FIFO (First-In, First-Out)</strong> principle; the earliest added element is removed first</td>
      </tr>
  </tbody>
</table>
<hr>
<h5 id="3-list-adt">3. List ADT<a hidden class="anchor" aria-hidden="true" href="#3-list-adt">#</a></h5>
<table>
  <thead>
      <tr>
          <th>Component</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>Object</strong></td>
          <td>A sequence of elements with index-based access</td>
      </tr>
      <tr>
          <td><strong>Operations</strong></td>
          <td><code>insert(i, x)</code>, <code>delete(i)</code>, <code>get(i)</code>, <code>find(x)</code>, &hellip;</td>
      </tr>
      <tr>
          <td><strong>Characteristics</strong></td>
          <td>Supports <strong>indexed access</strong>; can be implemented with arrays or linked structures</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="adt-vs-data-structure">ADT vs Data Structure<a hidden class="anchor" aria-hidden="true" href="#adt-vs-data-structure">#</a></h3>
<table>
  <thead>
      <tr>
          <th>Aspect</th>
          <th>ADT (Abstract Data Type)</th>
          <th>Data Structure</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Perspective</td>
          <td>Conceptual interface (what it does)</td>
          <td>Concrete implementation (how it works)</td>
      </tr>
      <tr>
          <td>Examples</td>
          <td>Stack, Queue, List</td>
          <td>Array, Linked List, Tree, Hash Table</td>
      </tr>
      <tr>
          <td>Focus</td>
          <td>What operations are supported</td>
          <td>How those operations are implemented efficiently</td>
      </tr>
      <tr>
          <td>Purpose</td>
          <td>Provide a simple and clear interface to users</td>
          <td>Optimize performance through implementation choices</td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="why-do-we-use-adts">Why Do We Use ADTs?<a hidden class="anchor" aria-hidden="true" href="#why-do-we-use-adts">#</a></h3>
<ol>
<li>
<p><strong>Abstraction</strong><br>
Users can use data structures without knowing internal details.</p>
</li>
<li>
<p><strong>Modularity (Flexibility)</strong><br>
If the ADT interface remains the same, the internal implementation can be changed without affecting user code.</p>
</li>
<li>
<p><strong>Reusability</strong><br>
ADT-based designs can be reused in various problem domains with minimal modification.</p>
</li>
<li>
<p><strong>Data Protection</strong><br>
The internal state is hidden, so users cannot tamper with it directly, ensuring consistency and integrity.</p>
</li>
</ol>
<hr>
<blockquote>
<p><strong>In summary</strong>:<br>
An ADT defines <strong>what</strong> data and operations are available, not <strong>how</strong> they are performed.<br>
This separation allows for clean, maintainable, and flexible software design.</p></blockquote>
<hr>
<h2 id="section-04-c-language-essentials-for-data-structures">Section 0.4. C Language Essentials for Data Structures<a hidden class="anchor" aria-hidden="true" href="#section-04-c-language-essentials-for-data-structures">#</a></h2>
<p>We will implement data structures using the C programming language.<br>
To do this effectively, we need to understand three core concepts:</p>
<ul>
<li><a href="#what-is-struct-type-in-c">What is a <strong>struct</strong> type in C?</a></li>
<li><a href="#how-do-we-use-pointers-in-c">How do we use <strong>pointers</strong> in C?</a></li>
<li><a href="#how-do-we-perform-dynamic-memory-allocation-in-c">How do we perform <strong>dynamic memory allocation</strong> in C?</a></li>
</ul>
<hr>
<h3 id="what-is-struct-type-in-c">What is <code>struct</code> type in C?<a hidden class="anchor" aria-hidden="true" href="#what-is-struct-type-in-c">#</a></h3>
<p>A <code>struct</code> (short for <strong>structure</strong>) in C is a <strong>user-defined data type</strong> that allows you to group variables of <strong>different types</strong> under a single name.</p>
<p>Unlike arrays, which access elements by index, a <code>struct</code> uses <strong>named fields</strong> to access its internal data.<br>
To access these fields, you use the <strong>dot operator (<code>.</code>)</strong>.</p>
<h4 id="example">Example:<a hidden class="anchor" aria-hidden="true" href="#example">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Node {        <span style="color:#75715e">// &#39;Node&#39; is the struct type name
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> data;        <span style="color:#75715e">// field
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">struct</span> Node<span style="color:#f92672">*</span> next; <span style="color:#75715e">// field
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> Node node1;
</span></span><span style="display:flex;"><span>node1.data <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;     <span style="color:#75715e">// Accessing the &#39;data&#39; field using the dot operator
</span></span></span></code></pre></div><hr>
<h4 id="memory-allocation-of-struct-type">Memory Allocation of &lsquo;struct&rsquo; Type<a hidden class="anchor" aria-hidden="true" href="#memory-allocation-of-struct-type">#</a></h4>
<ul>
<li>A <code>struct</code> is stored in a <strong>contiguous block of memory</strong>, and its fields are laid out <strong>in the order they are declared</strong>.</li>
<li>However, the <strong>total memory size</strong> of a <code>struct</code> may be <strong>larger than the sum of its fields’ sizes</strong> due to:
<ul>
<li><strong>Padding</strong>: extra space inserted between fields</li>
<li><strong>Alignment rules</strong>: used to optimize memory access performance on most architectures</li>
<li>You can check the actual memory allocated for a struct using sizeof(struct) in C.</li>
</ul>
</li>
</ul>
<p>These rules ensure that each field starts at a memory address aligned to its size (e.g., <code>int</code> on 4-byte boundaries, <code>double</code> on 8-byte boundaries).</p>
<h5 id="example-1">Example:<a hidden class="anchor" aria-hidden="true" href="#example-1">#</a></h5>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> studentInfo {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> age;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> gpa;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><table>
  <thead>
      <tr>
          <th>Field</th>
          <th>Type</th>
          <th>Size (bytes)</th>
          <th>Memory Offset</th>
          <th>Notes</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>name</code></td>
          <td><code>char[10]</code></td>
          <td>10</td>
          <td>0–9</td>
          <td>Starts at offset 0</td>
      </tr>
      <tr>
          <td><strong>padding</strong></td>
          <td>—</td>
          <td>2</td>
          <td>10–11</td>
          <td>To align <code>int</code> to a 4-byte boundary</td>
      </tr>
      <tr>
          <td><code>age</code></td>
          <td><code>int</code></td>
          <td>4</td>
          <td>12–15</td>
          <td>4-byte aligned</td>
      </tr>
      <tr>
          <td><code>gpa</code></td>
          <td><code>double</code></td>
          <td>8</td>
          <td>16–23</td>
          <td>8-byte aligned</td>
      </tr>
      <tr>
          <td><strong>total</strong></td>
          <td>—</td>
          <td><strong>24 bytes</strong></td>
          <td>—</td>
          <td><code>sizeof(struct studentInfo) == 24</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h3 id="typedef-in-c">&rsquo;typedef&rsquo; in C<a hidden class="anchor" aria-hidden="true" href="#typedef-in-c">#</a></h3>
<ul>
<li><code>typedef</code> is used to assign a custom alias(별칭) to an existing type.</li>
<li>It helps simplify complex type names and improve code readability, especially with <code>struct</code>.</li>
</ul>
<h4 id="example-2">Example<a hidden class="anchor" aria-hidden="true" href="#example-2">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">// typedef &lt;type definition&gt; &lt;alias&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node {          <span style="color:#75715e">// &#39;Node&#39; is the struct tag
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> data;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">struct</span> Node<span style="color:#f92672">*</span> next;
</span></span><span style="display:flex;"><span>} Node;                        <span style="color:#75715e">// &#39;Node&#39; is now a type alias
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">char</span> name[<span style="color:#ae81ff">10</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> age;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">double</span> gpa;
</span></span><span style="display:flex;"><span>} studentInfo;                 <span style="color:#75715e">// Anonymous struct with alias &#39;studentInfo&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>Node node1;
</span></span><span style="display:flex;"><span>studentInfo s1;
</span></span></code></pre></div><blockquote>
<p>In this example:
<code>Node</code> can now be used like a built-in type to declare variables
<code>studentInfo</code> represents a structure without an explicit tag name</p></blockquote>
<hr>
<h3 id="how-do-we-use-pointers-in-c">How Do We Use Pointers in C?<a hidden class="anchor" aria-hidden="true" href="#how-do-we-use-pointers-in-c">#</a></h3>
<p>A <strong>pointer</strong> is a variable that stores the <strong>memory address</strong> of another variable.</p>
<h4 id="basic-pointer-example">Basic Pointer Example<a hidden class="anchor" aria-hidden="true" href="#basic-pointer-example">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p;     <span style="color:#75715e">// Declare a pointer to an int
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>p <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>a;     <span style="color:#75715e">// &#39;&amp;&#39; (address-of operator): gets the address of variable &#39;a&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">11</span>;    <span style="color:#75715e">// &#39;*&#39; (dereference operator): access or modify the value pointed to by &#39;p&#39;
</span></span></span></code></pre></div><h4 id="type-specific-pointer-examples">Type-Specific Pointer Examples<a hidden class="anchor" aria-hidden="true" href="#type-specific-pointer-examples">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">double</span> <span style="color:#f92672">*</span>pf;   <span style="color:#75715e">// pf points to a double variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>pc;     <span style="color:#75715e">// pc points to a char variable
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">double</span> <span style="color:#f92672">**</span>ppf; <span style="color:#75715e">// ppf is a pointer to a pointer to a double
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>ppc[];  <span style="color:#75715e">// ppc is an array of pointers to char (e.g., array of strings)
</span></span></span></code></pre></div><blockquote>
<p>Pointer arithmetic depends on the size of the data type.<br>
For example, <code>pf + 1</code> increases the address by <code>sizeof(double)</code> (typically 8 bytes),<br>
while <code>pc + 1</code> increases by <code>sizeof(char)</code> (1 byte).</p></blockquote>
<hr>
<h4 id="special-types-of-pointers">Special Types of Pointers<a hidden class="anchor" aria-hidden="true" href="#special-types-of-pointers">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Type</th>
          <th>Description</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>NULL Pointer</strong></td>
          <td>A pointer that doesn&rsquo;t point to any valid memory location (used for safety checks)</td>
      </tr>
      <tr>
          <td><strong><code>void *</code> Pointer (Generic Pointer)</strong></td>
          <td>A pointer that can hold the address of any data type. It cannot be directly dereferenced without type casting, but can be automatically cast during assignment.</td>
      </tr>
  </tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>vp;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
</span></span><span style="display:flex;"><span>vp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;        <span style="color:#75715e">// okay: implicit cast to void*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">printf</span>(<span style="color:#e6db74">&#34;%d&#34;</span>, <span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)vp);  <span style="color:#75715e">// must cast back to correct type to dereference
</span></span></span></code></pre></div><hr>
<h4 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h4>
<ul>
<li><code>*</code> is used to declare a pointer and to dereference it.</li>
<li><code>&amp;</code> gives the address of a variable.</li>
<li>Pointers are powerful tools in C, essential for dynamic memory, arrays, structs, and efficient data structures.</li>
</ul>
<hr>
<h3 id="how-do-we-perform-dynamic-memory-allocation-in-c">How Do We Perform Dynamic Memory Allocation in C?<a hidden class="anchor" aria-hidden="true" href="#how-do-we-perform-dynamic-memory-allocation-in-c">#</a></h3>
<p><strong>Dynamic memory allocation</strong> means allocating memory <strong>during the execution</strong> of a program (at runtime), rather than at compile time.</p>
<ul>
<li>Memory is allocated <strong>as needed</strong>, and can be <strong>released</strong> once no longer required.</li>
<li>This enables <strong>efficient memory usage</strong>, especially for data structures with variable size (e.g., linked lists, trees, etc.).</li>
</ul>
<hr>
<h4 id="basic-example">Basic Example<a hidden class="anchor" aria-hidden="true" href="#basic-example">#</a></h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;stdlib.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>p;
</span></span><span style="display:flex;"><span>p <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)<span style="color:#a6e22e">malloc</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)); <span style="color:#75715e">// malloc returns void*, so explicit type casting is needed in C
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">if</span> (p <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>    <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// assigning value to dynamically allocated memory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">free</span>(p); <span style="color:#75715e">// Always free allocated memory after use to prevent memory leaks
</span></span></span></code></pre></div><hr>
<h4 id="key-functions-in-stdlibh">Key Functions in <code>stdlib.h</code><a hidden class="anchor" aria-hidden="true" href="#key-functions-in-stdlibh">#</a></h4>
<table>
  <thead>
      <tr>
          <th>Function</th>
          <th>Purpose</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>malloc(size)</code></td>
          <td>Allocates uninitialized memory of <code>size</code> bytes</td>
      </tr>
      <tr>
          <td><code>calloc(n, size)</code></td>
          <td>Allocates memory for <code>n</code> elements and initializes all to zero</td>
      </tr>
      <tr>
          <td><code>realloc(ptr, new_size)</code></td>
          <td>Resizes previously allocated memory block</td>
      </tr>
      <tr>
          <td><code>free(ptr)</code></td>
          <td>Frees the memory previously allocated by <code>malloc</code>, <code>calloc</code>, or <code>realloc</code></td>
      </tr>
  </tbody>
</table>
<hr>
<h4 id="notes">Notes<a hidden class="anchor" aria-hidden="true" href="#notes">#</a></h4>
<ul>
<li>Always check if <code>malloc()</code> or <code>calloc()</code> returns <code>NULL</code> (allocation failed).</li>
<li>Memory leaks can occur if <code>free()</code> is forgotten.</li>
<li>Memory allocated with <code>malloc()</code> remains until manually freed.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://Byngjoon.github.io/blog/tags/data-structures/">Data Structures</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://Byngjoon.github.io/blog/">Hyungtae</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
